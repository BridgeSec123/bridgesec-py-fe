import * as React from 'react';

const isExpandLine = (segment)=>{
    return 'hasLinesBefore' in segment || 'hasLinesAfter' in segment;
};
const getSegmentHeight = (segment, itemHeight, expandLineHeight)=>{
    return isExpandLine(segment) ? expandLineHeight : itemHeight * (segment.end - segment.start + 1);
};
/**
 * Merge two segments array into one, divide the segment if necessary.
 */ const mergeSegments = (tokens, diffs)=>{
    const result = [];
    let token;
    let diff;
    if (tokens.length && diffs.length) {
        tokens = [
            ...tokens
        ];
        diffs = [
            ...diffs
        ];
        token = {
            ...tokens.shift()
        };
        diff = {
            ...diffs.shift()
        };
        while(1){
            if (token.start === diff.start) {
                const end = Math.min(token.end, diff.end);
                result.push({
                    ...token,
                    ...diff,
                    end
                });
                token.start = diff.start = end;
            } else if (token.start < diff.start) {
                const end = Math.min(token.end, diff.start);
                result.push({
                    ...diff,
                    ...token,
                    end
                });
                token.start = end;
            } else {
                const end = Math.min(token.start, diff.end);
                result.push({
                    ...token,
                    ...diff,
                    end
                });
                diff.start = end;
            }
            if (!tokens.length || !diffs.length) break;
            if (token.start === token.end) token = {
                ...tokens.shift()
            };
            if (diff.start === diff.end) diff = {
                ...diffs.shift()
            };
        }
    }
    if (!tokens.length) result.push(...diffs.map((d)=>({
            ...d,
            token: token.token || 'plain'
        })));
    if (!diffs.length) result.push(...tokens);
    return result;
};

const calculatePlaceholderHeight = (segments, accTop, startSegment, startLine, endSegment, endLine, itemHeight, expandLineHeight, totalHeight)=>{
    if (!accTop.length) {
        return [
            0,
            0
        ];
    }
    let topHeight = 0;
    let bottomHeight = 0;
    const startSegmentItem = segments[startSegment];
    if (isExpandLine(startSegmentItem)) {
        topHeight = accTop[startSegment];
    } else {
        topHeight = accTop[startSegment] + (startLine - startSegmentItem.start) * itemHeight;
    }
    const endSegmentItem = segments[endSegment];
    if (isExpandLine(endSegmentItem)) {
        bottomHeight = totalHeight - accTop[endSegment] - expandLineHeight;
    } else {
        bottomHeight = totalHeight - accTop[endSegment] - (endLine - endSegmentItem.start) * itemHeight;
    }
    return [
        topHeight,
        bottomHeight
    ];
};
var calculatePlaceholderHeight$1 = calculatePlaceholderHeight;

const findVisibleLines = (segments, accTop, viewportTop, viewportBottom, itemHeight, expandLineHeight)=>{
    if (!accTop.length) {
        return [
            0,
            0,
            0,
            0
        ];
    }
    let startSegment = 0;
    let endSegment = 0;
    let startLine = 0;
    let endLine = 0;
    let l = 0;
    let r = segments.length - 1;
    // start segment
    while(1){
        const m = Math.floor((l + r) / 2);
        const top = accTop[m];
        const bottom = top + getSegmentHeight(segments[m], itemHeight, expandLineHeight);
        if (bottom <= viewportTop) {
            l = m + 1;
        } else {
            r = m;
        }
        if (l === r) {
            startSegment = l;
            break;
        }
    }
    // start line
    const startSegmentItem = segments[startSegment];
    if (isExpandLine(startSegmentItem)) {
        startLine = startSegmentItem.start;
    } else {
        startLine = startSegmentItem.start + Math.floor((viewportTop - accTop[startSegment]) / itemHeight);
    }
    // end segment
    l = 0;
    r = segments.length - 1;
    while(1){
        const m = Math.floor((l + r + 1) / 2);
        const top = accTop[m];
        if (top >= viewportBottom) {
            r = m - 1;
        } else {
            l = m;
        }
        if (l === r) {
            endSegment = l;
            break;
        }
    }
    // end line
    const endSegmentItem = segments[endSegment];
    if (isExpandLine(endSegmentItem)) {
        endLine = endSegmentItem.end;
    } else {
        endLine = endSegmentItem.start + Math.ceil((viewportBottom - accTop[endSegment]) / itemHeight);
    }
    return [
        startSegment,
        startLine,
        endSegment,
        endLine
    ];
};
var findVisibleLines$1 = findVisibleLines;

var bin = {};

Object.defineProperty(bin, "__esModule", {
    value: true
});
bin.applyPatch = bin.calcPatch = lcs_1 = bin.lcs = bin.diff = bin.diff_core = void 0;
function diff_internal(state, c) {
    const { b , eq , stack_base  } = state;
    let { i , N , j , M , Z , stack_top  } = state;
    for(;;){
        switch(c){
            case 0:
                {
                    Z_block: while(N > 0 && M > 0){
                        b.fill(0, 0, 2 * Z);
                        const W = N - M;
                        const L = N + M;
                        const parity = L & 1;
                        const offsetx = i + N - 1;
                        const offsety = j + M - 1;
                        const hmax = (L + parity) / 2;
                        let z;
                        h_loop: for(let h = 0; h <= hmax; h++){
                            const kmin = 2 * Math.max(0, h - M) - h;
                            const kmax = h - 2 * Math.max(0, h - N);
                            for(let k = kmin; k <= kmax; k += 2){
                                const gkm = b[k - 1 - Z * Math.floor((k - 1) / Z)];
                                const gkp = b[k + 1 - Z * Math.floor((k + 1) / Z)];
                                const u = k === -h || k !== h && gkm < gkp ? gkp : gkm + 1;
                                const v = u - k;
                                let x = u;
                                let y = v;
                                while(x < N && y < M && eq(i + x, j + y))x++, y++;
                                b[k - Z * Math.floor(k / Z)] = x;
                                if (parity === 1 && (z = W - k) >= 1 - h && z < h && x + b[Z + z - Z * Math.floor(z / Z)] >= N) {
                                    if (h > 1 || x !== u) {
                                        stack_base[stack_top++] = i + x;
                                        stack_base[stack_top++] = N - x;
                                        stack_base[stack_top++] = j + y;
                                        stack_base[stack_top++] = M - y;
                                        N = u;
                                        M = v;
                                        Z = 2 * (Math.min(N, M) + 1);
                                        continue Z_block;
                                    } else break h_loop;
                                }
                            }
                            for(let k = kmin; k <= kmax; k += 2){
                                const pkm = b[Z + k - 1 - Z * Math.floor((k - 1) / Z)];
                                const pkp = b[Z + k + 1 - Z * Math.floor((k + 1) / Z)];
                                const u = k === -h || k !== h && pkm < pkp ? pkp : pkm + 1;
                                const v = u - k;
                                let x = u;
                                let y = v;
                                while(x < N && y < M && eq(offsetx - x, offsety - y))x++, y++;
                                b[Z + k - Z * Math.floor(k / Z)] = x;
                                if (parity === 0 && (z = W - k) >= -h && z <= h && x + b[z - Z * Math.floor(z / Z)] >= N) {
                                    if (h > 0 || x !== u) {
                                        stack_base[stack_top++] = i + N - u;
                                        stack_base[stack_top++] = u;
                                        stack_base[stack_top++] = j + M - v;
                                        stack_base[stack_top++] = v;
                                        N = N - x;
                                        M = M - y;
                                        Z = 2 * (Math.min(N, M) + 1);
                                        continue Z_block;
                                    } else break h_loop;
                                }
                            }
                        }
                        if (N === M) continue;
                        if (M > N) {
                            i += N;
                            j += N;
                            M -= N;
                            N = 0;
                        } else {
                            i += M;
                            j += M;
                            N -= M;
                            M = 0;
                        }
                        break;
                    }
                    if (N + M !== 0) {
                        if (state.pxe === i || state.pye === j) {
                            state.pxe = i + N;
                            state.pye = j + M;
                        } else {
                            const sx = state.pxs;
                            state.oxs = state.pxs;
                            state.oxe = state.pxe;
                            state.oys = state.pys;
                            state.oye = state.pye;
                            state.pxs = i;
                            state.pxe = i + N;
                            state.pys = j;
                            state.pye = j + M;
                            if (sx >= 0) {
                                state.i = i;
                                state.N = N;
                                state.j = j;
                                state.M = M;
                                state.Z = Z;
                                state.stack_top = stack_top;
                                return 1;
                            }
                        }
                    }
                }
            case 1:
                {
                    if (stack_top === 0) return 2;
                    M = stack_base[--stack_top];
                    j = stack_base[--stack_top];
                    N = stack_base[--stack_top];
                    i = stack_base[--stack_top];
                    Z = 2 * (Math.min(N, M) + 1);
                    c = 0;
                }
        }
    }
}
let DiffGen = class DiffGen {
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const { state , result  } = this;
        if (this.c > 1) {
            result.done = true;
            result.value = undefined;
            return result;
        }
        const c = diff_internal(state, this.c);
        this.c = c;
        if (c === 1) {
            result.value = [
                state.oxs,
                state.oxe,
                state.oys,
                state.oye
            ];
            return result;
        }
        if (state.pxs >= 0) {
            result.value = [
                state.pxs,
                state.pxe,
                state.pys,
                state.pye
            ];
            return result;
        }
        result.done = true;
        result.value = undefined;
        return result;
    }
    constructor(state){
        this.state = state;
        this.c = 0;
        this.result = {
            value: null,
            done: false
        };
    }
};
function diff_core(i, N, j, M, eq) {
    const Z = (Math.min(N, M) + 1) * 2;
    const L = N + M;
    const b = new (L < 256 ? Uint8Array : L < 65536 ? Uint16Array : Uint32Array)(2 * Z);
    return new DiffGen({
        i,
        N,
        j,
        M,
        Z,
        b,
        eq,
        pxs: -1,
        pxe: -1,
        pys: -1,
        pye: -1,
        oxs: -1,
        oxe: -1,
        oys: -1,
        oye: -1,
        stack_top: 0,
        stack_base: []
    });
}
bin.diff_core = diff_core;
function diff(xs, ys) {
    let [i, N, M] = [
        0,
        xs.length,
        ys.length
    ];
    while(i < N && i < M && xs[i] === ys[i])i++;
    if (i === N && i === M) return [][Symbol.iterator]();
    while(xs[--N] === ys[--M] && N > i && M > i);
    const eq = (x, y)=>xs[x] === ys[y];
    return diff_core(i, N + 1 - i, i, M + 1 - i, eq);
}
bin.diff = diff;
let LCSGen = class LCSGen {
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const rec = this.diff.next();
        if (rec.done) {
            const { i , j , N  } = this;
            if (i < N) {
                rec.done = false;
                rec.value = [
                    i,
                    j,
                    N - i
                ];
                this.i = N;
            }
            return rec;
        }
        const v = rec.value;
        const sx = v[0];
        const ex = v[1];
        const ey = v[3];
        const { i , j  } = this;
        if (i !== sx) {
            v.length--;
            v[0] = i;
            v[1] = j;
            v[2] = sx - i;
        }
        this.i = ex;
        this.j = ey;
        return rec;
    }
    constructor(diff, N){
        this.diff = diff;
        this.N = N;
        this.i = 0;
        this.j = 0;
    }
};
function lcs(xs, ys) {
    return new LCSGen(diff(xs, ys), xs.length);
}
var lcs_1 = bin.lcs = lcs;
function* calcPatch(xs, ys) {
    const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
    for (const v of diff(xs, ys)){
        v[2] = slice.call(ys, v[2], v[3]);
        yield v;
    }
}
bin.calcPatch = calcPatch;
function* applyPatch(xs, patch) {
    let i = 0;
    const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
    for (const [dels, dele, ins] of patch){
        if (i < dels) yield slice.call(xs, i, dels);
        if (ins.length > 0) yield ins;
        i = dele;
    }
    if (i < xs.length) yield slice.call(xs, i);
}
bin.applyPatch = applyPatch;

const getOriginalIndices = (arr, separatorLength)=>{
    const result = [];
    let index = 0;
    for (const item of arr){
        result.push(index);
        index += item.length + separatorLength;
    }
    result.push(index - separatorLength);
    return result;
};
const filterEmptyParts = (arr)=>{
    return arr.filter((item)=>item.end > item.start);
};
const getInlineDiff = (l, r, options)=>{
    let resultL = [];
    let resultR = [];
    let lastL = 0;
    let lastR = 0;
    if (options.mode === 'word') {
        const wordSeparator = options.wordSeparator || ' ';
        const lArr = l.split(wordSeparator);
        const rArr = r.split(wordSeparator);
        /**
     * The iter array contains the information about replacement, which is an array of
     * tuple `[startL, startR, length]`.
     *
     * e.g. `[1, 2, 3]` means replace `lArr[1...1+3]` to `rArr[2...2+3]` (include the end).
     */ const iter = [
            ...lcs_1(lArr, rArr)
        ];
        const separatorLength = wordSeparator.length;
        const indicesL = getOriginalIndices(lArr, separatorLength);
        const indicesR = getOriginalIndices(rArr, separatorLength);
        for (const [sl, sr, length] of iter){
            if (sl > lastL) {
                resultL.push({
                    type: 'remove',
                    start: indicesL[lastL],
                    end: indicesL[sl]
                });
            }
            if (sr > lastR) {
                resultR.push({
                    type: 'add',
                    start: indicesR[lastR],
                    end: indicesR[sr]
                });
            }
            lastL = sl + length;
            lastR = sr + length;
            resultL.push({
                start: indicesL[sl],
                end: indicesL[lastL]
            });
            resultR.push({
                start: indicesR[sr],
                end: indicesR[lastR]
            });
        }
        if (l.length > lastL) {
            resultL.push({
                type: 'remove',
                start: indicesL[lastL],
                end: l.length
            });
        }
        if (r.length > lastR) {
            resultR.push({
                type: 'add',
                start: indicesR[lastR],
                end: r.length
            });
        }
        resultL = filterEmptyParts(resultL);
        resultR = filterEmptyParts(resultR);
        return [
            resultL,
            resultR
        ];
    }
    const iter = lcs_1(l, r);
    for (const [sl, sr, length] of iter){
        if (sl > lastL) {
            resultL.push({
                type: 'remove',
                start: lastL,
                end: sl
            });
        }
        if (sr > lastR) {
            resultR.push({
                type: 'add',
                start: lastR,
                end: sr
            });
        }
        lastL = sl + length;
        lastR = sr + length;
        resultL.push({
            start: sl,
            end: lastL
        });
        resultR.push({
            start: sr,
            end: lastR
        });
    }
    if (l.length > lastL) {
        resultL.push({
            type: 'remove',
            start: lastL,
            end: l.length
        });
    }
    if (r.length > lastR) {
        resultR.push({
            type: 'add',
            start: lastR,
            end: r.length
        });
    }
    resultL = filterEmptyParts(resultL);
    resultR = filterEmptyParts(resultR);
    return [
        resultL,
        resultR
    ];
};
var getInlineDiff$1 = getInlineDiff;

const syntaxHighlightLine = (enabled, text, offset)=>{
    if (!enabled) {
        return [
            {
                token: 'plain',
                start: offset,
                end: text.length + offset
            }
        ];
    }
    if (text === 'undefined' || text === 'Infinity' || text === '-Infinity' || text === 'NaN' || /^\d+n$/i.test(text) || text.startsWith('Symbol(') || text.startsWith('function') || text.startsWith('(')) {
        return [
            {
                token: 'invalid',
                start: offset,
                end: text.length + offset
            }
        ];
    }
    if (!Number.isNaN(Number(text))) {
        return [
            {
                token: 'number',
                start: offset,
                end: text.length + offset
            }
        ];
    }
    if (text === 'true' || text === 'false') {
        return [
            {
                token: 'boolean',
                start: offset,
                end: text.length + offset
            }
        ];
    }
    if (text === 'null') {
        return [
            {
                token: 'null',
                start: offset,
                end: text.length + offset
            }
        ];
    }
    if (text.startsWith('"')) {
        if (text.endsWith(': [') || text.endsWith(': {')) {
            return [
                {
                    token: 'key',
                    start: offset,
                    end: text.length - 3 + offset
                },
                {
                    token: 'punctuation',
                    start: text.length - 3,
                    end: text.length - 2 + offset
                },
                {
                    token: 'plain',
                    start: text.length - 2,
                    end: text.length - 1 + offset
                },
                {
                    token: 'punctuation',
                    start: text.length - 1,
                    end: text.length + offset
                }
            ];
        }
        let pairedQuoteIndex = 1;
        while(pairedQuoteIndex < text.length){
            if (text[pairedQuoteIndex] === '"') break;
            if (text[pairedQuoteIndex] === '\\') ++pairedQuoteIndex;
            ++pairedQuoteIndex;
        }
        if (pairedQuoteIndex === text.length - 1) {
            return [
                {
                    token: 'string',
                    start: offset,
                    end: text.length + offset
                }
            ];
        }
        return [
            {
                token: 'key',
                start: offset,
                end: pairedQuoteIndex + 1 + offset
            },
            {
                token: 'punctuation',
                start: pairedQuoteIndex + 1,
                end: pairedQuoteIndex + 2 + offset
            },
            {
                token: 'plain',
                start: pairedQuoteIndex + 2,
                end: pairedQuoteIndex + 3 + offset
            },
            ...syntaxHighlightLine(enabled, text.substring(pairedQuoteIndex + 3), offset + pairedQuoteIndex + 3)
        ];
    }
    if (text === '{' || text === '}' || text === '[' || text === ']') {
        return [
            {
                token: 'punctuation',
                start: offset,
                end: text.length + offset
            }
        ];
    }
    // should this be expected?
    return [
        {
            token: 'plain',
            start: offset,
            end: text.length + offset
        }
    ];
};
var getInlineSyntaxHighlight = syntaxHighlightLine;

const defaultOptions = {
    threshold: 8,
    margin: 3
};
const getSegments = (l, r, options, jsonsAreEqual)=>{
    if (!options || jsonsAreEqual) {
        return [
            {
                start: 0,
                end: l.length,
                isEqual: false
            }
        ];
    }
    const segments = [];
    for(let i = 0; i < l.length; i++){
        if (l[i].type === 'equal' && r[i].type === 'equal') {
            if (segments.length && segments[segments.length - 1].isEqual) {
                segments[segments.length - 1].end++;
            } else {
                segments.push({
                    start: i,
                    end: i + 1,
                    isEqual: true
                });
            }
        } else {
            if (segments.length && !segments[segments.length - 1].isEqual) {
                segments[segments.length - 1].end++;
            } else {
                segments.push({
                    start: i,
                    end: i + 1,
                    isEqual: false
                });
            }
        }
    }
    const _options = options === true ? defaultOptions : {
        ...defaultOptions,
        ...options
    };
    const { threshold , margin  } = _options;
    if (threshold < margin * 2 + 1) {
        // eslint-disable-next-line no-console, max-len
        console.warn(`Threshold (${threshold}) is no more than 2 margins + 1 "expand" line (${margin} * 2 + 1), it's not necessary to hide unchanged areas which have less than ${margin * 2 + 1} lines.`);
    }
    const result = [];
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        if (!segment.isEqual || segment.end - segment.start < threshold || segment.end - segment.start <= margin * 2 + 1) {
            result.push(segment);
            continue;
        }
        if (!i) {
            result.push({
                hasLinesBefore: true,
                hasLinesAfter: false,
                start: 0,
                end: segment.end - margin,
                isEqual: true
            });
            result.push({
                start: segment.end - margin,
                end: segment.end,
                isEqual: true
            });
        } else if (i === segments.length - 1) {
            result.push({
                start: segment.start,
                end: segment.start + margin,
                isEqual: true
            });
            result.push({
                hasLinesBefore: false,
                hasLinesAfter: true,
                start: segment.start + margin,
                end: l.length,
                isEqual: true
            });
        } else {
            result.push({
                start: segment.start,
                end: segment.start + margin,
                isEqual: true
            });
            result.push({
                hasLinesBefore: true,
                hasLinesAfter: true,
                start: segment.start + margin,
                end: segment.end - margin,
                isEqual: true
            });
            result.push({
                start: segment.end - margin,
                end: segment.end,
                isEqual: true
            });
        }
    }
    return result;
};
var getSegments$1 = getSegments;

const DEFAULT_INDENT = 2;
const DEFAULT_EXPAND_MORE_LINES_LIMIT = 20;
const DEFAULT_TEXTS = {
    noChangeDetected: 'No change detected'
};
const Viewer = (props)=>{
    const [linesLeft, linesRight] = props.diff;
    const jsonsAreEqual = React.useMemo(()=>{
        return linesLeft.length === linesRight.length && linesLeft.every((item)=>item.type === 'equal') && linesRight.every((item)=>item.type === 'equal');
    }, [
        linesLeft,
        linesRight
    ]);
    const mergedTexts = {
        ...DEFAULT_TEXTS,
        ...props.texts
    };
    const lineNumberWidth = props.lineNumbers ? `calc(${String(linesLeft.length).length}ch + 16px)` : 0;
    const indent = props.indent ?? DEFAULT_INDENT;
    const indentChar = indent === 'tab' ? '\t' : ' ';
    const indentSize = indent === 'tab' ? 1 : indent;
    const inlineDiffOptions = {
        mode: props.inlineDiffOptions?.mode || 'char',
        wordSeparator: props.inlineDiffOptions?.wordSeparator || ''
    };
    const hideUnchangedLines = props.hideUnchangedLines ?? false;
    const { scrollContainer: _scrollContainer = 'body' , itemHeight =18 , expandLineHeight =26  } = !props.virtual || props.virtual === true ? {} : props.virtual;
    const scrollContainer = _scrollContainer === 'body' ? document.body : document.querySelector(_scrollContainer);
    // Use these refs to keep the diff data and segments sync,
    // or it may cause runtime error because of their mismatch.
    // Do not use the states to render, use the refs to render and use `updateViewer` to update.
    const linesLeftRef = React.useRef(linesLeft);
    const linesRightRef = React.useRef(linesRight);
    const segmentsRef = React.useRef(getSegments$1(linesLeft, linesRight, hideUnchangedLines, jsonsAreEqual));
    const accTopRef = React.useRef([]);
    const totalHeightRef = React.useRef(0);
    const tbodyRef = React.useRef(null);
    const [, forceUpdate] = React.useState({});
    const updateViewer = ()=>{
        accTopRef.current = [];
        if (props.virtual) {
            let acc = 0;
            for (const segment of segmentsRef.current){
                if (isExpandLine(segment)) {
                    accTopRef.current.push(acc);
                    acc += expandLineHeight;
                } else {
                    accTopRef.current.push(acc);
                    acc += itemHeight * (segment.end - segment.start);
                }
            }
            totalHeightRef.current = segmentsRef.current.reduce((acc, segment)=>{
                if (!isExpandLine(segment)) {
                    return acc + (segment.end - segment.start) * itemHeight;
                }
                return acc + expandLineHeight;
            }, 0);
        }
        forceUpdate({});
    };
    React.useEffect(()=>{
        linesLeftRef.current = linesLeft;
        linesRightRef.current = linesRight;
        segmentsRef.current = getSegments$1(linesLeft, linesRight, hideUnchangedLines, jsonsAreEqual);
        updateViewer();
    }, [
        hideUnchangedLines,
        linesLeft,
        linesRight
    ]);
    React.useEffect(()=>{
        if (!props.virtual || !scrollContainer) {
            return;
        }
        const onScroll = ()=>forceUpdate({});
        scrollContainer.addEventListener('scroll', onScroll);
        return ()=>{
            scrollContainer.removeEventListener('scroll', onScroll);
        };
    }, [
        props.virtual,
        scrollContainer
    ]);
    const onExpandBefore = (segmentIndex)=>(lines)=>{
            const newSegments = [
                ...segmentsRef.current
            ];
            const newSegment = newSegments[segmentIndex];
            newSegments[segmentIndex] = {
                ...newSegment,
                end: Math.max(newSegment.end - lines, newSegment.start)
            };
            if (segmentIndex + 1 < segmentsRef.current.length - 1) {
                newSegments[segmentIndex + 1] = {
                    ...newSegments[segmentIndex + 1],
                    start: Math.max(newSegment.end - lines, newSegment.start)
                };
            }
            segmentsRef.current = newSegments;
            updateViewer();
        };
    const onExpandAfter = (segmentIndex)=>(lines)=>{
            const newSegments = [
                ...segmentsRef.current
            ];
            const newSegment = newSegments[segmentIndex];
            newSegments[segmentIndex] = {
                ...newSegment,
                start: Math.min(newSegment.start + lines, newSegment.end)
            };
            if (segmentIndex > 1) {
                newSegments[segmentIndex - 1] = {
                    ...newSegments[segmentIndex - 1],
                    end: Math.min(newSegment.start + lines, newSegment.end)
                };
            }
            segmentsRef.current = newSegments;
            updateViewer();
        };
    const onExpandAll = (segmentIndex)=>()=>{
            const newSegments = [
                ...segmentsRef.current
            ];
            const newSegment = newSegments[segmentIndex];
            newSegments[segmentIndex] = {
                ...newSegment,
                start: newSegment.start,
                end: newSegment.start
            };
            if (segmentIndex + 1 < segmentsRef.current.length - 1) {
                newSegments[segmentIndex + 1] = {
                    ...newSegments[segmentIndex + 1],
                    start: newSegment.start
                };
            } else {
                newSegments[segmentIndex - 1] = {
                    ...newSegments[segmentIndex - 1],
                    end: newSegment.end
                };
            }
            segmentsRef.current = newSegments;
            updateViewer();
        };
    const renderInlineResult = (text, info = [], comma = false, syntaxHighlightEnabled = false)=>/*#__PURE__*/ React.createElement(React.Fragment, null, info.map((item, index)=>{
            const frag = text.slice(item.start, item.end);
            if (!item.type && !item.token) {
                return frag;
            }
            const className = [
                item.type ? `inline-diff-${item.type}` : '',
                item.token ? `token ${item.token}` : ''
            ].filter(Boolean).join(' ');
            return /*#__PURE__*/ React.createElement("span", {
                key: `${index}-${item.type}-${frag}`,
                className: className
            }, frag);
        }), comma && (syntaxHighlightEnabled ? /*#__PURE__*/ React.createElement("span", {
            className: "token punctuation"
        }, ",") : ','));
    const renderLine = (index, syntaxHighlightEnabled)=>{
        const l = linesLeftRef.current[index];
        const r = linesRightRef.current[index];
        const [lDiff, rDiff] = props.highlightInlineDiff && l.type === 'modify' && r.type === 'modify' ? getInlineDiff$1(l.text, r.text, inlineDiffOptions) : [
            [],
            []
        ];
        const lTokens = getInlineSyntaxHighlight(syntaxHighlightEnabled, l.text, 0);
        const rTokens = getInlineSyntaxHighlight(syntaxHighlightEnabled, r.text, 0);
        const lResult = mergeSegments(lTokens, lDiff);
        const rResult = mergeSegments(rTokens, rDiff);
        const bgLeft = l.type !== 'equal' ? props.bgColour?.[l.type] ?? '' : '';
        const bgRight = r.type !== 'equal' ? props.bgColour?.[r.type] ?? '' : '';
        return(// eslint-disable-next-line react/no-array-index-key
        /*#__PURE__*/ React.createElement("tr", {
            key: index
        }, props.lineNumbers && /*#__PURE__*/ React.createElement("td", {
            className: `line-${l.type} line-number`,
            style: {
                backgroundColor: bgLeft
            }
        }, l.lineNumber), /*#__PURE__*/ React.createElement("td", {
            className: `line-${l.type}`,
            style: {
                backgroundColor: bgLeft
            }
        }, /*#__PURE__*/ React.createElement("pre", null, l.text && indentChar.repeat(l.level * indentSize), renderInlineResult(l.text, lResult, l.comma, syntaxHighlightEnabled))), props.lineNumbers && /*#__PURE__*/ React.createElement("td", {
            className: `line-${r.type} line-number`,
            style: {
                backgroundColor: bgRight
            }
        }, r.lineNumber), /*#__PURE__*/ React.createElement("td", {
            className: `line-${r.type}`,
            style: {
                backgroundColor: bgRight
            }
        }, /*#__PURE__*/ React.createElement("pre", null, r.text && indentChar.repeat(r.level * indentSize), renderInlineResult(r.text, rResult, r.comma, syntaxHighlightEnabled)))));
    };
    const renderExpandLine = (hasLinesBefore, hasLinesAfter, expandMoreLinesLimit, index)=>{
        return /*#__PURE__*/ React.createElement(React.Fragment, null, hasLinesBefore && /*#__PURE__*/ React.createElement("button", {
            onClick: ()=>onExpandBefore(index)(expandMoreLinesLimit)
        }, "⭡ Show ", expandMoreLinesLimit, " lines before"), /*#__PURE__*/ React.createElement("button", {
            onClick: ()=>onExpandAll(index)()
        }, "⭥ Show all unchanged lines"), hasLinesAfter && /*#__PURE__*/ React.createElement("button", {
            onClick: ()=>onExpandAfter(index)(expandMoreLinesLimit)
        }, "⭣ Show ", expandMoreLinesLimit, " lines after"));
    };
    const renderSegment = (segment, index, renderStart, renderEnd, syntaxHighlightEnabled)=>{
        let { start , end  } = segment;
        start = Math.max(start, renderStart);
        end = Math.min(end, renderEnd);
        if (start === end) {
            return null;
        }
        if (!isExpandLine(segment)) {
            return Array(end - start).fill(0).map((_, index)=>renderLine(start + index, syntaxHighlightEnabled));
        }
        const { hasLinesBefore , hasLinesAfter  } = segment;
        const expandMoreLinesLimit = typeof hideUnchangedLines === 'boolean' ? DEFAULT_EXPAND_MORE_LINES_LIMIT : hideUnchangedLines.expandMoreLinesLimit || DEFAULT_EXPAND_MORE_LINES_LIMIT;
        return [
            /*#__PURE__*/ React.createElement("tr", {
                key: `expand-line-${index}`,
                className: "expand-line"
            }, /*#__PURE__*/ React.createElement("td", {
                colSpan: 4,
                className: `${hasLinesBefore ? 'has-lines-before' : ''} ${hasLinesAfter ? 'has-lines-after' : ''}`
            }, typeof hideUnchangedLines !== 'boolean' && hideUnchangedLines.expandLineRenderer ? hideUnchangedLines.expandLineRenderer({
                hasLinesBefore,
                hasLinesAfter,
                onExpandBefore: onExpandBefore(index),
                onExpandAfter: onExpandAfter(index),
                onExpandAll: onExpandAll(index)
            }) : renderExpandLine(hasLinesBefore, hasLinesAfter, expandMoreLinesLimit, index)))
        ];
    };
    const renderTbody = (syntaxHighlightEnabled)=>{
        if (jsonsAreEqual && hideUnchangedLines) {
            return /*#__PURE__*/ React.createElement("tr", {
                key: "message-line",
                className: "message-line"
            }, /*#__PURE__*/ React.createElement("td", {
                colSpan: 4
            }, mergedTexts.noChangeDetected));
        }
        if (!props.virtual) {
            return segmentsRef.current.map((item, index)=>renderSegment(item, index, 0, linesLeftRef.current.length, syntaxHighlightEnabled));
        }
        const containerHeight = scrollContainer?.clientHeight ?? 0;
        const scrollTop = scrollContainer?.scrollTop ?? 0;
        const scrollBottom = scrollTop + containerHeight;
        let t = tbodyRef.current;
        let firstElementTop = t?.offsetTop ?? 0;
        while(t?.offsetParent && t?.offsetParent !== scrollContainer){
            t = t.offsetParent;
            firstElementTop += t.offsetTop;
        }
        if (firstElementTop > scrollBottom || firstElementTop + totalHeightRef.current < scrollTop) {
            return /*#__PURE__*/ React.createElement("tr", null, /*#__PURE__*/ React.createElement("td", {
                colSpan: 4,
                style: {
                    height: `${totalHeightRef.current}px`
                }
            }));
        }
        const viewportTop = scrollTop - firstElementTop;
        const viewportBottom = scrollBottom - firstElementTop;
        const [startSegment, startLine, endSegment, endLine] = findVisibleLines$1(segmentsRef.current, accTopRef.current, viewportTop, viewportBottom, itemHeight, expandLineHeight);
        const [topHeight, bottomHeight] = calculatePlaceholderHeight$1(segmentsRef.current, accTopRef.current, startSegment, startLine, endSegment, endLine, itemHeight, expandLineHeight, totalHeightRef.current);
        const visibleSegments = segmentsRef.current.slice(startSegment, endSegment + 1);
        return visibleSegments.length ? /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement("tr", null, /*#__PURE__*/ React.createElement("td", {
            colSpan: 4,
            style: {
                height: topHeight,
                padding: 0
            }
        })), visibleSegments.map((segment, index)=>renderSegment(segment, index, startLine, endLine, syntaxHighlightEnabled)), /*#__PURE__*/ React.createElement("tr", null, /*#__PURE__*/ React.createElement("td", {
            colSpan: 4,
            style: {
                height: bottomHeight,
                padding: 0
            }
        }))) : /*#__PURE__*/ React.createElement("tr", null, /*#__PURE__*/ React.createElement("td", {
            colSpan: 4,
            style: {
                height: `${totalHeightRef.current}px`
            }
        }));
    };
    const renderMeasureLine = ()=>/*#__PURE__*/ React.createElement("colgroup", {
            className: "measure-line"
        }, props.lineNumbers && /*#__PURE__*/ React.createElement("col", {
            style: {
                width: lineNumberWidth
            }
        }), /*#__PURE__*/ React.createElement("col", null), props.lineNumbers && /*#__PURE__*/ React.createElement("col", {
            style: {
                width: lineNumberWidth
            }
        }), /*#__PURE__*/ React.createElement("col", null));
    const classes = [
        'json-diff-viewer',
        props.virtual && 'json-diff-viewer-virtual',
        props.syntaxHighlight && `json-diff-viewer-theme-${props.syntaxHighlight.theme || 'monokai'}`,
        props.className
    ].filter(Boolean).join(' ');
    const syntaxHighlightEnabled = !!props.syntaxHighlight;
    return /*#__PURE__*/ React.createElement("table", {
        className: classes,
        style: props.style
    }, renderMeasureLine(), /*#__PURE__*/ React.createElement("tbody", {
        ref: tbodyRef
    }, renderTbody(syntaxHighlightEnabled)));
};
Viewer.displayName = 'Viewer';

export { Viewer as default };
