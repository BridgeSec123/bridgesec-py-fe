import {
  Route,
  dist_exports
} from "./chunk-4VBIH4KP.js";
import {
  _slicedToArray
} from "./chunk-HMELMOQG.js";
import {
  _asyncToGenerator,
  require_regenerator
} from "./chunk-2IZBQ2FT.js";
import {
  _objectWithoutProperties
} from "./chunk-CO5KWJMW.js";
import {
  AuthSdkError,
  toRelativeUrl
} from "./chunk-KEGDWWU2.js";
import "./chunk-MAWLMG4L.js";
import {
  _defineProperty
} from "./chunk-6AV3SFNV.js";
import "./chunk-3IHV7RO6.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@okta/okta-react/bundles/okta-react.esm.js
var import_regenerator = __toESM(require_regenerator());
var React = __toESM(require_react());

// node_modules/compare-versions/index.mjs
function compareVersions(v1, v2) {
  const n1 = validateAndParse(v1);
  const n2 = validateAndParse(v2);
  const p1 = n1.pop();
  const p2 = n2.pop();
  const r = compareSegments(n1, n2);
  if (r !== 0) return r;
  if (p1 && p2) {
    return compareSegments(p1.split("."), p2.split("."));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }
  return 0;
}
var validate = (v) => typeof v === "string" && /^[v\d]/.test(v) && semver.test(v);
var compare = (v1, v2, operator) => {
  assertValidOperator(operator);
  const res = compareVersions(v1, v2);
  return operatorResMap[operator].includes(res);
};
var satisfies = (v, r) => {
  const m = r.match(/^([<>=~^]+)/);
  const op = m ? m[1] : "=";
  if (op !== "^" && op !== "~") return compare(v, r, op);
  const [v1, v2, v3] = validateAndParse(v);
  const [r1, r2, r3] = validateAndParse(r);
  if (compareStrings(v1, r1) !== 0) return false;
  if (op === "^") {
    return compareSegments([v2, v3], [r2, r3]) >= 0;
  }
  if (compareStrings(v2, r2) !== 0) return false;
  return compareStrings(v3, r3) >= 0;
};
compareVersions.validate = validate;
compareVersions.compare = compare;
compareVersions.satisfies = satisfies;
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var validateAndParse = (v) => {
  if (typeof v !== "string") {
    throw new TypeError("Invalid argument expected string");
  }
  const match = v.match(semver);
  if (!match) {
    throw new Error(`Invalid argument not valid semver ('${v}' received)`);
  }
  match.shift();
  return match;
};
var isWildcard = (s) => s === "*" || s === "x" || s === "X";
var tryParse = (v) => {
  const n = parseInt(v, 10);
  return isNaN(n) ? v : n;
};
var forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
var compareStrings = (a, b) => {
  if (isWildcard(a) || isWildcard(b)) return 0;
  const [ap, bp] = forceType(tryParse(a), tryParse(b));
  if (ap > bp) return 1;
  if (ap < bp) return -1;
  return 0;
};
var compareSegments = (a, b) => {
  for (let i = 0; i < Math.max(a.length, b.length); i++) {
    const r = compareStrings(a[i] || 0, b[i] || 0);
    if (r !== 0) return r;
  }
  return 0;
};
var operatorResMap = {
  ">": [1],
  ">=": [0, 1],
  "=": [0],
  "<=": [-1, 0],
  "<": [-1]
};
var allowedOperators = Object.keys(operatorResMap);
var assertValidOperator = (op) => {
  if (typeof op !== "string") {
    throw new TypeError(
      `Invalid operator type, expected string but got ${typeof op}`
    );
  }
  if (allowedOperators.indexOf(op) === -1) {
    throw new Error(
      `Invalid operator, expected one of ${allowedOperators.join("|")}`
    );
  }
};

// node_modules/@okta/okta-react/bundles/okta-react.esm.js
var OktaContext = React.createContext(null);
var useOktaAuth = function useOktaAuth2() {
  return React.useContext(OktaContext);
};
var OktaError = function OktaError2(_ref) {
  var error = _ref.error;
  if (error.name && error.message) {
    return React.createElement("p", null, error.name, ": ", error.message);
  }
  return React.createElement("p", null, "Error: ", error.toString());
};
var Security = function Security2(_ref) {
  var oktaAuth = _ref.oktaAuth, restoreOriginalUri = _ref.restoreOriginalUri, onAuthRequired = _ref.onAuthRequired, children = _ref.children;
  var _React$useState = React.useState(function() {
    if (!oktaAuth) {
      return null;
    }
    return oktaAuth.authStateManager.getAuthState();
  }), _React$useState2 = _slicedToArray(_React$useState, 2), authState = _React$useState2[0], setAuthState = _React$useState2[1];
  React.useEffect(function() {
    if (!oktaAuth || !restoreOriginalUri) {
      return;
    }
    if (oktaAuth.options.restoreOriginalUri) {
      console.warn("Two custom restoreOriginalUri callbacks are detected. The one from the OktaAuth configuration will be overridden by the provided restoreOriginalUri prop from the Security component.");
    }
    oktaAuth.options.restoreOriginalUri = function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee(oktaAuth2, originalUri) {
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", restoreOriginalUri(oktaAuth2, originalUri));
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }();
  }, []);
  React.useEffect(function() {
    if (!oktaAuth) {
      return;
    }
    if (oktaAuth._oktaUserAgent) {
      oktaAuth._oktaUserAgent.addEnvironment("@okta/okta-react".concat("/", "6.9.0"));
    } else {
      console.warn("_oktaUserAgent is not available on auth SDK instance. Please use okta-auth-js@^5.3.1 .");
    }
    var currentAuthState = oktaAuth.authStateManager.getAuthState();
    if (currentAuthState !== authState) {
      setAuthState(currentAuthState);
    }
    var handler = function handler2(authState2) {
      setAuthState(authState2);
    };
    oktaAuth.authStateManager.subscribe(handler);
    oktaAuth.start();
    return function() {
      oktaAuth.authStateManager.unsubscribe(handler);
    };
  }, [oktaAuth]);
  if (!oktaAuth) {
    var err = new AuthSdkError("No oktaAuth instance passed to Security Component.");
    return React.createElement(OktaError, {
      error: err
    });
  }
  if (!restoreOriginalUri) {
    var _err = new AuthSdkError("No restoreOriginalUri callback passed to Security Component.");
    return React.createElement(OktaError, {
      error: _err
    });
  }
  if (!oktaAuth._oktaUserAgent) {
    console.warn("_oktaUserAgent is not available on auth SDK instance. Please use okta-auth-js@^5.3.1 .");
  } else {
    var isAuthJsSupported = compare(oktaAuth._oktaUserAgent.getVersion(), {
      "minSupportedVersion": "5.3.1"
    }.minSupportedVersion, ">=");
    if (!isAuthJsSupported) {
      var _err2 = new AuthSdkError("\n        Passed in oktaAuth is not compatible with the SDK,\n        minimum supported okta-auth-js version is ".concat({
        "minSupportedVersion": "5.3.1"
      }.minSupportedVersion, ".\n      "));
      return React.createElement(OktaError, {
        error: _err2
      });
    }
  }
  return React.createElement(OktaContext.Provider, {
    value: {
      oktaAuth,
      authState,
      _onAuthRequired: onAuthRequired
    }
  }, children);
};
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var withOktaAuth = function withOktaAuth2(ComponentToWrap) {
  var WrappedComponent = function WrappedComponent2(props) {
    var oktaAuthProps = useOktaAuth();
    return React.createElement(ComponentToWrap, _objectSpread$1(_objectSpread$1({}, oktaAuthProps), props));
  };
  WrappedComponent.displayName = "withOktaAuth_" + (ComponentToWrap.displayName || ComponentToWrap.name);
  return WrappedComponent;
};
var handledRedirect = false;
var LoginCallback = function LoginCallback2(_ref) {
  var errorComponent = _ref.errorComponent, _ref$loadingElement = _ref.loadingElement, loadingElement = _ref$loadingElement === void 0 ? null : _ref$loadingElement, onAuthResume = _ref.onAuthResume;
  var _useOktaAuth = useOktaAuth(), oktaAuth = _useOktaAuth.oktaAuth, authState = _useOktaAuth.authState;
  var _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), callbackError = _React$useState2[0], setCallbackError = _React$useState2[1];
  var ErrorReporter = errorComponent || OktaError;
  React.useEffect(function() {
    var isInteractionRequired = oktaAuth.idx.isInteractionRequired || oktaAuth.isInteractionRequired.bind(oktaAuth);
    if (onAuthResume && isInteractionRequired()) {
      onAuthResume();
      return;
    }
    if (!handledRedirect) {
      oktaAuth.handleLoginRedirect()["catch"](function(e) {
        setCallbackError(e);
      });
      handledRedirect = true;
    }
  }, [oktaAuth]);
  var authError = authState === null || authState === void 0 ? void 0 : authState.error;
  var displayError = callbackError || authError;
  if (displayError) {
    return React.createElement(ErrorReporter, {
      error: displayError
    });
  }
  return loadingElement;
};
var _excluded = ["onAuthRequired", "errorComponent"];
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var useMatch;
if ("useRouteMatch" in dist_exports) {
  useMatch = dist_exports["useRouteMatch" in dist_exports ? "useRouteMatch" : ""];
} else {
  useMatch = function useMatch2() {
    throw new AuthSdkError('Unsupported: SecureRoute only works with react-router-dom v5 or any router library with compatible APIs. See examples under the "samples" folder for how to implement your own custom SecureRoute Component.');
  };
}
var SecureRoute = function SecureRoute2(_ref) {
  var onAuthRequired = _ref.onAuthRequired, errorComponent = _ref.errorComponent, routeProps = _objectWithoutProperties(_ref, _excluded);
  var _useOktaAuth = useOktaAuth(), oktaAuth = _useOktaAuth.oktaAuth, authState = _useOktaAuth.authState, _onAuthRequired = _useOktaAuth._onAuthRequired;
  var match = useMatch(routeProps);
  var pendingLogin = React.useRef(false);
  var _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), handleLoginError = _React$useState2[0], setHandleLoginError = _React$useState2[1];
  var ErrorReporter = errorComponent || OktaError;
  React.useEffect(function() {
    var handleLogin = function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
        var originalUri, onAuthRequiredFn;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!pendingLogin.current) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                pendingLogin.current = true;
                originalUri = toRelativeUrl(window.location.href, window.location.origin);
                oktaAuth.setOriginalUri(originalUri);
                onAuthRequiredFn = onAuthRequired || _onAuthRequired;
                if (!onAuthRequiredFn) {
                  _context.next = 11;
                  break;
                }
                _context.next = 9;
                return onAuthRequiredFn(oktaAuth);
              case 9:
                _context.next = 13;
                break;
              case 11:
                _context.next = 13;
                return oktaAuth.signInWithRedirect();
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function handleLogin2() {
        return _ref2.apply(this, arguments);
      };
    }();
    if (!match) {
      return;
    }
    if (!authState) {
      return;
    }
    if (authState.isAuthenticated) {
      pendingLogin.current = false;
      return;
    }
    if (!authState.isAuthenticated) {
      handleLogin()["catch"](function(err) {
        setHandleLoginError(err);
      });
    }
  }, [authState, oktaAuth, match, onAuthRequired, _onAuthRequired]);
  if (handleLoginError) {
    return React.createElement(ErrorReporter, {
      error: handleLoginError
    });
  }
  if (!authState || !authState.isAuthenticated) {
    return null;
  }
  return React.createElement(Route, _objectSpread({}, routeProps));
};
export {
  LoginCallback,
  OktaContext,
  SecureRoute,
  Security,
  useOktaAuth,
  withOktaAuth
};
/*! Bundled license information:

@okta/okta-react/bundles/okta-react.esm.js:
  (*!
   * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)
*/
//# sourceMappingURL=@okta_okta-react.js.map
