import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/json-diff-kit/dist/differ.js
var cleanFields = (obj) => {
  if (typeof obj === "undefined" || obj === null || typeof obj === "bigint" || Number.isNaN(obj) || obj === Infinity || obj === -Infinity) {
    return void 0;
  }
  if ([
    "string",
    "number",
    "boolean"
  ].includes(typeof obj)) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(cleanFields).filter((t) => typeof t !== "undefined");
  }
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const cleaned = cleanFields(value);
    if (typeof cleaned !== "undefined") {
      result[key] = cleaned;
    }
  }
  return result;
};
var cleanFields$1 = cleanFields;
var concat = (a, b, prependEach = false) => {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    throw new Error("Both arguments should be arrays.");
  }
  const lenA = a.length;
  const lenB = b.length;
  const len = lenA + lenB;
  const result = new Array(len);
  if (prependEach) {
    for (let i = 0; i < lenB; i++) {
      result[i] = b[lenB - i - 1];
    }
    for (let i = 0; i < lenA; i++) {
      result[i + lenB] = a[i];
    }
    return result;
  }
  for (let i = 0; i < lenA; i++) {
    result[i] = a[i];
  }
  for (let i = 0; i < lenB; i++) {
    result[i + lenA] = b[i];
  }
  return result;
};
var concat$1 = concat;
var detectCircular = (value, map = /* @__PURE__ */ new Map()) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (map.has(value)) {
    return true;
  }
  map.set(value, true);
  if (Array.isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      if (detectCircular(value[i], map)) {
        return true;
      }
    }
    return false;
  }
  for (const key in value) {
    if (detectCircular(value[key], map)) {
      return true;
    }
  }
  return false;
};
var detectCircular$1 = detectCircular;
var stringify = (obj, replacer, space, depth = Infinity, undefinedBehavior) => {
  if (!obj || typeof obj !== "object") {
    let result = void 0;
    if (!Number.isNaN(obj) && obj !== Infinity && obj !== -Infinity && typeof obj !== "bigint") {
      result = JSON.stringify(obj, replacer, space);
    }
    if (result === void 0) {
      switch (undefinedBehavior) {
        case UndefinedBehavior.throw:
          throw new Error(`Value is not valid in JSON, got ${String(obj)}`);
        case UndefinedBehavior.stringify:
          return stringifyInvalidValue(obj);
        default:
          throw new Error(`Should not reach here, please report this bug.`);
      }
    }
    return result;
  }
  const t = depth < 1 ? '"..."' : Array.isArray(obj) ? `[${obj.map((v) => stringify(v, replacer, space, depth - 1, undefinedBehavior)).join(",")}]` : `{${Object.keys(obj).map((k) => `"${k}": ${stringify(obj[k], replacer, space, depth - 1, undefinedBehavior)}`).join(", ")}}`;
  return JSON.stringify(JSON.parse(t), replacer, space);
};
var stringifyInvalidValue = (value) => {
  if (value === void 0) {
    return "undefined";
  }
  if (value === Infinity) {
    return "Infinity";
  }
  if (value === -Infinity) {
    return "-Infinity";
  }
  if (Number.isNaN(value)) {
    return "NaN";
  }
  if (typeof value === "bigint") {
    return `${value}n`;
  }
  return String(value);
};
var stringify$1 = stringify;
var formatValue = (value, depth = Infinity, pretty = false, undefinedBehavior = UndefinedBehavior.stringify) => {
  if (value === null) {
    return "null";
  }
  if (Array.isArray(value) || typeof value === "object") {
    return stringify$1(value, void 0, pretty ? 1 : void 0, depth, undefinedBehavior);
  }
  return stringify$1(value, void 0, void 0, void 0, undefinedBehavior);
};
var formatValue$1 = formatValue;
var getOrderByType = (value) => {
  if (typeof value === "boolean") {
    return 0;
  }
  if (typeof value === "number") {
    return 1;
  }
  if (typeof value === "string") {
    return 2;
  }
  if (value === null) {
    return 3;
  }
  if (Array.isArray(value)) {
    return 4;
  }
  if (typeof value === "object") {
    return 5;
  }
  if (typeof value === "symbol") {
    return 6;
  }
  if (typeof value === "function") {
    return 7;
  }
  if (typeof value === "bigint") {
    return 8;
  }
  return -1;
};
var cmp = (a, b, options) => {
  var _a, _b;
  const orderByMapA = (_a = options.keyOrdersMap) == null ? void 0 : _a.get(a);
  const orderByMapB = (_b = options.keyOrdersMap) == null ? void 0 : _b.get(b);
  if (orderByMapA !== void 0 && orderByMapB !== void 0) {
    return orderByMapA - orderByMapB;
  }
  const orderByTypeA = getOrderByType(a);
  const orderByTypeB = getOrderByType(b);
  if (orderByTypeA !== orderByTypeB) {
    return orderByTypeA - orderByTypeB;
  }
  if (a === null && b === null || Array.isArray(a) && Array.isArray(b) || orderByTypeA === 5 && orderByTypeB === 5) {
    return 0;
  }
  switch (typeof a) {
    case "number":
      if (Number.isNaN(a) && Number.isNaN(b) || a === Infinity && b === Infinity || a === -Infinity && b === -Infinity) {
        return 0;
      }
      return a - b;
    case "string":
      if (options.ignoreCase) {
        a = a.toLowerCase();
        b = b.toLowerCase();
      }
      return a < b ? -1 : a > b ? 1 : 0;
    case "boolean":
      return +a - +b;
    case "symbol":
    case "function":
      return String(a).localeCompare(String(b));
  }
  if (typeof a === "bigint" && typeof b === "bigint") {
    const result = BigInt(a) - BigInt(b);
    return result < 0 ? -1 : result > 0 ? 1 : 0;
  }
  return String(a).localeCompare(String(b));
};
var cmp$1 = cmp;
var getType = (value) => {
  if (Array.isArray(value)) {
    return "array";
  }
  if (value === null) {
    return "null";
  }
  return typeof value;
};
var getType$1 = getType;
var prettyAppendLines = (linesLeft, linesRight, keyLeft, keyRight, valueLeft, valueRight, level, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const valueCmpOptions = {
    ignoreCase: options.ignoreCase
  };
  const _resultLeft = formatValue$1(valueLeft, options.maxDepth, true, options.undefinedBehavior).split("\n");
  const _resultRight = formatValue$1(valueRight, options.maxDepth, true, options.undefinedBehavior).split("\n");
  if (cmp$1(valueLeft, valueRight, valueCmpOptions) !== 0) {
    if (options.showModifications) {
      const maxLines = Math.max(_resultLeft.length, _resultRight.length);
      for (let i = _resultLeft.length; i < maxLines; i++) {
        _resultLeft.push("");
      }
      for (let i = _resultRight.length; i < maxLines; i++) {
        _resultRight.push("");
      }
      linesLeft.push({
        level,
        type: "modify",
        text: keyLeft ? `"${keyLeft}": ${_resultLeft[0]}` : _resultLeft[0]
      });
      for (let i = 1; i < _resultLeft.length; i++) {
        linesLeft.push({
          level: level + (((_b = (_a = _resultLeft[i].match(/^\s+/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0),
          type: "modify",
          text: _resultLeft[i].replace(/^\s+/, "").replace(/,$/g, "")
        });
      }
      for (let i = _resultLeft.length; i < maxLines; i++) {
        linesLeft.push({
          level,
          type: "equal",
          text: ""
        });
      }
      linesRight.push({
        level,
        type: "modify",
        text: keyRight ? `"${keyRight}": ${_resultRight[0]}` : _resultRight[0]
      });
      for (let i = 1; i < _resultRight.length; i++) {
        linesRight.push({
          level: level + (((_d = (_c = _resultRight[i].match(/^\s+/)) == null ? void 0 : _c[0]) == null ? void 0 : _d.length) || 0),
          type: "modify",
          text: _resultRight[i].replace(/^\s+/, "").replace(/,$/g, "")
        });
      }
      for (let i = _resultRight.length; i < maxLines; i++) {
        linesRight.push({
          level,
          type: "equal",
          text: ""
        });
      }
    } else {
      linesLeft.push({
        level,
        type: "remove",
        text: keyLeft ? `"${keyLeft}": ${_resultLeft[0]}` : _resultLeft[0]
      });
      for (let i = 1; i < _resultLeft.length; i++) {
        linesLeft.push({
          level: level + (((_f = (_e = _resultLeft[i].match(/^\s+/)) == null ? void 0 : _e[0]) == null ? void 0 : _f.length) || 0),
          type: "remove",
          text: _resultLeft[i].replace(/^\s+/, "").replace(/,$/g, "")
        });
      }
      for (let i = 0; i < _resultRight.length; i++) {
        linesLeft.push({
          level,
          type: "equal",
          text: ""
        });
      }
      for (let i = 0; i < _resultLeft.length; i++) {
        linesRight.push({
          level,
          type: "equal",
          text: ""
        });
      }
      linesRight.push({
        level,
        type: "add",
        text: keyRight ? `"${keyRight}": ${_resultRight[0]}` : _resultRight[0]
      });
      for (let i = 1; i < _resultRight.length; i++) {
        linesRight.push({
          level: level + (((_h = (_g = _resultRight[i].match(/^\s+/)) == null ? void 0 : _g[0]) == null ? void 0 : _h.length) || 0),
          type: "add",
          text: _resultRight[i].replace(/^\s+/, "").replace(/,$/g, "")
        });
      }
    }
  } else {
    const maxLines = Math.max(_resultLeft.length, _resultRight.length);
    for (let i = _resultLeft.length; i < maxLines; i++) {
      _resultLeft.push("");
    }
    for (let i = _resultRight.length; i < maxLines; i++) {
      _resultRight.push("");
    }
    linesLeft.push({
      level,
      type: "equal",
      text: keyLeft ? `"${keyLeft}": ${_resultLeft[0]}` : _resultLeft[0]
    });
    for (let i = 1; i < _resultLeft.length; i++) {
      linesLeft.push({
        level: level + (((_j = (_i = _resultLeft[i].match(/^\s+/)) == null ? void 0 : _i[0]) == null ? void 0 : _j.length) || 0),
        type: "equal",
        text: _resultLeft[i].replace(/^\s+/, "").replace(/,$/g, "")
      });
    }
    linesRight.push({
      level,
      type: "equal",
      text: keyRight ? `"${keyRight}": ${_resultRight[0]}` : _resultRight[0]
    });
    for (let i = 1; i < _resultRight.length; i++) {
      linesRight.push({
        level: level + (((_l = (_k = _resultRight[i].match(/^\s+/)) == null ? void 0 : _k[0]) == null ? void 0 : _l.length) || 0),
        type: "equal",
        text: _resultRight[i].replace(/^\s+/, "").replace(/,$/g, "")
      });
    }
  }
};
var prettyAppendLines$1 = prettyAppendLines;
var sortKeys = (arr, options) => {
  return arr.sort((a, b) => cmp$1(a, b, {
    ignoreCase: options.ignoreCaseForKey
  }));
};
var sortKeys$1 = sortKeys;
var diffObject = (lhs, rhs, level = 1, options, arrayDiffFunc) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  if (level > (options.maxDepth || Infinity)) {
    return [
      [
        {
          level,
          type: "equal",
          text: "..."
        }
      ],
      [
        {
          level,
          type: "equal",
          text: "..."
        }
      ]
    ];
  }
  let linesLeft = [];
  let linesRight = [];
  if (lhs === null && rhs === null || lhs === void 0 && rhs === void 0) {
    return [
      linesLeft,
      linesRight
    ];
  } else if (lhs === null || lhs === void 0) {
    const addedLines = stringify$1(rhs, void 0, 1, void 0, options.undefinedBehavior).split("\n");
    for (let i = 0; i < addedLines.length; i++) {
      linesLeft.push({
        level,
        type: "equal",
        text: ""
      });
      linesRight.push({
        level: level + (((_b = (_a = addedLines[i].match(/^\s+/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0),
        type: "add",
        text: addedLines[i].replace(/^\s+/, "").replace(/,$/g, "")
      });
    }
    return [
      linesLeft,
      linesRight
    ];
  } else if (rhs === null || rhs === void 0) {
    const addedLines = stringify$1(lhs, void 0, 1, void 0, options.undefinedBehavior).split("\n");
    for (let i = 0; i < addedLines.length; i++) {
      linesLeft.push({
        level: level + (((_d = (_c = addedLines[i].match(/^\s+/)) == null ? void 0 : _c[0]) == null ? void 0 : _d.length) || 0),
        type: "remove",
        text: addedLines[i].replace(/^\s+/, "").replace(/,$/g, "")
      });
      linesRight.push({
        level,
        type: "equal",
        text: ""
      });
    }
    return [
      linesLeft,
      linesRight
    ];
  }
  const keysLeft = Object.keys(lhs);
  const keysRight = Object.keys(rhs);
  const keyOrdersMap = /* @__PURE__ */ new Map();
  if (!options.preserveKeyOrder) {
    sortKeys$1(keysLeft, options);
    sortKeys$1(keysRight, options);
  } else if (options.preserveKeyOrder === "before") {
    for (let i = 0; i < keysLeft.length; i++) {
      keyOrdersMap.set(keysLeft[i], i);
    }
    for (let i = 0; i < keysRight.length; i++) {
      if (!keyOrdersMap.has(keysRight[i])) {
        keyOrdersMap.set(keysRight[i], keysLeft.length + i);
      }
    }
    keysRight.sort((a, b) => keyOrdersMap.get(a) - keyOrdersMap.get(b));
  } else if (options.preserveKeyOrder === "after") {
    for (let i = 0; i < keysRight.length; i++) {
      keyOrdersMap.set(keysRight[i], i);
    }
    for (let i = 0; i < keysLeft.length; i++) {
      if (!keyOrdersMap.has(keysLeft[i])) {
        keyOrdersMap.set(keysLeft[i], keysRight.length + i);
      }
    }
    keysLeft.sort((a, b) => keyOrdersMap.get(a) - keyOrdersMap.get(b));
  }
  const keysCmpOptions = {
    ignoreCase: options.ignoreCaseForKey,
    keyOrdersMap
  };
  while (keysLeft.length || keysRight.length) {
    const keyLeft = keysLeft[0];
    const keyRight = keysRight[0];
    const keyCmpResult = cmp$1(keyLeft, keyRight, keysCmpOptions);
    if (keyCmpResult === 0) {
      if (getType$1(lhs[keyLeft]) !== getType$1(rhs[keyRight])) {
        prettyAppendLines$1(linesLeft, linesRight, keyLeft, keyRight, lhs[keyLeft], rhs[keyRight], level, options);
      } else if (Array.isArray(lhs[keyLeft])) {
        const arrLeft = [
          ...lhs[keyLeft]
        ];
        const arrRight = [
          ...rhs[keyRight]
        ];
        const [resLeft, resRight] = arrayDiffFunc(arrLeft, arrRight, keyLeft, keyRight, level, options, [], []);
        linesLeft = concat$1(linesLeft, resLeft);
        linesRight = concat$1(linesRight, resRight);
      } else if (lhs[keyLeft] === null) {
        linesLeft.push({
          level,
          type: "equal",
          text: `"${keyLeft}": null`
        });
        linesRight.push({
          level,
          type: "equal",
          text: `"${keyRight}": null`
        });
      } else if (typeof lhs[keyLeft] === "object") {
        const result = diffObject(lhs[keyLeft], rhs[keyRight], level + 1, options, arrayDiffFunc);
        linesLeft.push({
          level,
          type: "equal",
          text: `"${keyLeft}": {`
        });
        linesLeft = concat$1(linesLeft, result[0]);
        linesLeft.push({
          level,
          type: "equal",
          text: "}"
        });
        linesRight.push({
          level,
          type: "equal",
          text: `"${keyRight}": {`
        });
        linesRight = concat$1(linesRight, result[1]);
        linesRight.push({
          level,
          type: "equal",
          text: "}"
        });
      } else {
        prettyAppendLines$1(linesLeft, linesRight, keyLeft, keyRight, lhs[keyLeft], rhs[keyRight], level, options);
      }
    } else if (keysLeft.length && keysRight.length) {
      if (keyCmpResult < 0) {
        const addedLines = stringify$1(lhs[keyLeft], void 0, 1, void 0, options.undefinedBehavior).split("\n");
        for (let i = 0; i < addedLines.length; i++) {
          const text = addedLines[i].replace(/^\s+/, "").replace(/,$/g, "");
          linesLeft.push({
            level: level + (((_f = (_e = addedLines[i].match(/^\s+/)) == null ? void 0 : _e[0]) == null ? void 0 : _f.length) || 0),
            type: "remove",
            text: i ? text : `"${keyLeft}": ${text}`
          });
          linesRight.push({
            level,
            type: "equal",
            text: ""
          });
        }
      } else {
        const addedLines = stringify$1(rhs[keyRight], void 0, 1, void 0, options.undefinedBehavior).split("\n");
        for (let i = 0; i < addedLines.length; i++) {
          const text = addedLines[i].replace(/^\s+/, "").replace(/,$/g, "");
          linesLeft.push({
            level,
            type: "equal",
            text: ""
          });
          linesRight.push({
            level: level + (((_h = (_g = addedLines[i].match(/^\s+/)) == null ? void 0 : _g[0]) == null ? void 0 : _h.length) || 0),
            type: "add",
            text: i ? text : `"${keyRight}": ${text}`
          });
        }
      }
    } else if (keysLeft.length) {
      const addedLines = stringify$1(lhs[keyLeft], void 0, 1, void 0, options.undefinedBehavior).split("\n");
      for (let i = 0; i < addedLines.length; i++) {
        const text = addedLines[i].replace(/^\s+/, "").replace(/,$/g, "");
        linesLeft.push({
          level: level + (((_j = (_i = addedLines[i].match(/^\s+/)) == null ? void 0 : _i[0]) == null ? void 0 : _j.length) || 0),
          type: "remove",
          text: i ? text : `"${keyLeft}": ${text}`
        });
        linesRight.push({
          level,
          type: "equal",
          text: ""
        });
      }
    } else if (keysRight.length) {
      const addedLines = stringify$1(rhs[keyRight], void 0, 1, void 0, options.undefinedBehavior).split("\n");
      for (let i = 0; i < addedLines.length; i++) {
        const text = addedLines[i].replace(/^\s+/, "").replace(/,$/g, "");
        linesLeft.push({
          level,
          type: "equal",
          text: ""
        });
        linesRight.push({
          level: level + (((_l = (_k = addedLines[i].match(/^\s+/)) == null ? void 0 : _k[0]) == null ? void 0 : _l.length) || 0),
          type: "add",
          text: i ? text : `"${keyRight}": ${text}`
        });
      }
    }
    if (!keyLeft) {
      keysRight.shift();
    } else if (!keyRight) {
      keysLeft.shift();
    } else if (keyCmpResult === 0) {
      keysLeft.shift();
      keysRight.shift();
    } else if (keyCmpResult < 0) {
      keysLeft.shift();
    } else {
      keysRight.shift();
    }
  }
  if (linesLeft.length !== linesRight.length) {
    throw new Error("Diff error: length not match for left & right, please report a bug with your data.");
  }
  return [
    linesLeft,
    linesRight
  ];
};
var diffObject$1 = diffObject;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([
      key,
      value
    ]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$3 = root$7.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$1 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$2;
var baseGetTag$3 = _baseGetTag;
var isObject$1 = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1;
var isMasked = _isMasked;
var isObject = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype;
var objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$6(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$6;
var getNative$5 = _getNative;
var root$5 = _root;
var Map$4 = getNative$5(root$5, "Map");
var _Map = Map$4;
var getNative$4 = _getNative;
var nativeCreate$4 = getNative$4(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache;
var Map$2 = _Map;
var MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([
        key,
        value
      ]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache;
var setCacheAdd = _setCacheAdd;
var setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache;
var arraySome = _arraySome;
var cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$4 = _root;
var Uint8Array$1 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$1;
function mapToArray$1(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [
      key,
      value
    ];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol2 = _Symbol;
var Uint8Array2 = _Uint8Array;
var eq = eq_1;
var equalArrays$1 = _equalArrays;
var mapToArray = _mapToArray;
var setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1;
var COMPARE_UNORDERED_FLAG = 2;
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag$1 = "[object Error]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$2 = "[object DataView]";
var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object == other + "";
    case mapTag$2:
      var convert = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$1;
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var arrayPush = _arrayPush;
var isArray$2 = isArray_1;
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter;
var stubArray = stubArray_1;
var objectProto$6 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$4(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$4;
var baseGetTag$2 = _baseGetTag;
var isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$2 = isObjectLike_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag;
var isLength$1 = isLength_1;
var isObjectLike$1 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var mapTag$1 = "[object Map]";
var numberTag = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag$1 = "[object Set]";
var stringTag = "[object String]";
var weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes;
var isArguments = isArguments_1;
var isArray$1 = isArray_1;
var isBuffer$1 = isBuffer$2.exports;
var isIndex = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$3 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction = isFunction_1;
var isLength = isLength_1;
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike = isArrayLike_1;
function keys$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative;
var root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative;
var root = _root;
var WeakMap$1 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map$1 = _Map;
var Promise$1 = _Promise;
var Set$1 = _Set;
var WeakMap = _WeakMap;
var baseGetTag = _baseGetTag;
var toSource = _toSource;
var mapTag = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag = "[object Set]";
var weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap);
var getTag$1 = baseGetTag;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap && getTag$1(new WeakMap()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack = _Stack;
var equalArrays = _equalArrays;
var equalByTag = _equalByTag;
var equalObjects = _equalObjects;
var getTag = _getTag;
var isArray = isArray_1;
var isBuffer = isBuffer$2.exports;
var isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep;
var isObjectLike = isObjectLike_1;
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var baseIsEqual = _baseIsEqual;
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result = customizer ? customizer(value, other) : void 0;
  return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
}
var isEqualWith_1 = isEqualWith;
var isEqual = (a, b, options) => {
  if (options.ignoreCase) {
    return typeof a === "string" && typeof b === "string" && a.toLowerCase() === b.toLowerCase();
  }
  if (typeof a === "symbol" && typeof b === "symbol") {
    return a.toString() === b.toString();
  }
  if (options.recursiveEqual) {
    return isEqualWith_1(a, b, (a2, b2) => options.ignoreCase ? typeof a2 === "string" && typeof b2 === "string" ? a2.toLowerCase() === b2.toLowerCase() : void 0 : void 0);
  }
  return a === b;
};
var isEqual$1 = isEqual;
var shallowSimilarity = (left, right) => {
  if (left === right) {
    return 1;
  }
  if (left === null || right === null) {
    return 0;
  }
  if (typeof left !== "object" || typeof right !== "object") {
    return 0;
  }
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  const leftKeysLength = leftKeys.length;
  const rightKeysLength = rightKeys.length;
  if (leftKeysLength === 0 || rightKeysLength === 0) {
    return 0;
  }
  const leftKeysSet = new Set(leftKeys);
  const rightKeysSet = new Set(rightKeys);
  const intersection = new Set([
    ...leftKeysSet
  ].filter((x) => rightKeysSet.has(x)));
  if (intersection.size === 0) {
    return 0;
  }
  if (intersection.size === 1 && (leftKeysLength === 1 || rightKeysLength === 1) && left[leftKeys[0]] !== right[rightKeys[0]]) {
    return 0;
  }
  return Math.max(intersection.size / leftKeysLength, intersection.size / rightKeysLength);
};
var shallowSimilarity$1 = shallowSimilarity;
var lcs = (arrLeft, arrRight, keyLeft, keyRight, level, options) => {
  var _a, _b, _c, _d;
  const f = Array(arrLeft.length + 1).fill(0).map(() => Array(arrRight.length + 1).fill(0));
  const backtrack = Array(arrLeft.length + 1).fill(0).map(() => Array(arrRight.length + 1).fill(0));
  for (let i2 = 1; i2 <= arrLeft.length; i2++) {
    backtrack[i2][0] = "up";
  }
  for (let j2 = 1; j2 <= arrRight.length; j2++) {
    backtrack[0][j2] = "left";
  }
  for (let i2 = 1; i2 <= arrLeft.length; i2++) {
    for (let j2 = 1; j2 <= arrRight.length; j2++) {
      const typeI = getType$1(arrLeft[i2 - 1]);
      const typeJ = getType$1(arrRight[j2 - 1]);
      if (typeI === typeJ && (typeI === "array" || typeI === "object")) {
        if (options.recursiveEqual) {
          if (isEqual$1(arrLeft[i2 - 1], arrRight[j2 - 1], options) || shallowSimilarity$1(arrLeft[i2 - 1], arrRight[j2 - 1]) > 0.5) {
            f[i2][j2] = f[i2 - 1][j2 - 1] + 1;
            backtrack[i2][j2] = "diag";
          } else if (f[i2 - 1][j2] >= f[i2][j2 - 1]) {
            f[i2][j2] = f[i2 - 1][j2];
            backtrack[i2][j2] = "up";
          } else {
            f[i2][j2] = f[i2][j2 - 1];
            backtrack[i2][j2] = "left";
          }
        } else {
          f[i2][j2] = f[i2 - 1][j2 - 1] + 1;
          backtrack[i2][j2] = "diag";
        }
      } else if (isEqual$1(arrLeft[i2 - 1], arrRight[j2 - 1], options)) {
        f[i2][j2] = f[i2 - 1][j2 - 1] + 1;
        backtrack[i2][j2] = "diag";
      } else if (f[i2 - 1][j2] >= f[i2][j2 - 1]) {
        f[i2][j2] = f[i2 - 1][j2];
        backtrack[i2][j2] = "up";
      } else {
        f[i2][j2] = f[i2][j2 - 1];
        backtrack[i2][j2] = "left";
      }
    }
  }
  let i = arrLeft.length;
  let j = arrRight.length;
  let tLeft = [];
  let tRight = [];
  while (i > 0 || j > 0) {
    if (backtrack[i][j] === "diag") {
      const type = getType$1(arrLeft[i - 1]);
      if (options.recursiveEqual && (type === "array" || type === "object") && isEqual$1(arrLeft[i - 1], arrRight[j - 1], options)) {
        const reversedLeft = [];
        const reversedRight = [];
        prettyAppendLines$1(reversedLeft, reversedRight, "", "", arrLeft[i - 1], arrRight[j - 1], level + 1, options);
        tLeft = concat$1(tLeft, reversedLeft.reverse(), true);
        tRight = concat$1(tRight, reversedRight.reverse(), true);
      } else if (type === "array") {
        const [l, r] = diffArrayLCS(arrLeft[i - 1], arrRight[j - 1], keyLeft, keyRight, level + 1, options);
        tLeft = concat$1(tLeft, l.reverse(), true);
        tRight = concat$1(tRight, r.reverse(), true);
      } else if (type === "object") {
        const [l, r] = diffObject$1(arrLeft[i - 1], arrRight[j - 1], level + 2, options, diffArrayLCS);
        tLeft.unshift({
          level: level + 1,
          type: "equal",
          text: "}"
        });
        tRight.unshift({
          level: level + 1,
          type: "equal",
          text: "}"
        });
        tLeft = concat$1(tLeft, l.reverse(), true);
        tRight = concat$1(tRight, r.reverse(), true);
        tLeft.unshift({
          level: level + 1,
          type: "equal",
          text: "{"
        });
        tRight.unshift({
          level: level + 1,
          type: "equal",
          text: "{"
        });
      } else {
        const reversedLeft = [];
        const reversedRight = [];
        prettyAppendLines$1(reversedLeft, reversedRight, "", "", arrLeft[i - 1], arrRight[j - 1], level + 1, options);
        tLeft = concat$1(tLeft, reversedLeft.reverse(), true);
        tRight = concat$1(tRight, reversedRight.reverse(), true);
      }
      i--;
      j--;
    } else if (backtrack[i][j] === "up") {
      if (options.showModifications && i > 1 && backtrack[i - 1][j] === "left") {
        const typeLeft = getType$1(arrLeft[i - 1]);
        const typeRight = getType$1(arrRight[j - 1]);
        if (typeLeft === typeRight) {
          if (typeLeft === "array") {
            const [l, r] = diffArrayLCS(arrLeft[i - 1], arrRight[j - 1], keyLeft, keyRight, level + 1, options);
            tLeft = concat$1(tLeft, l.reverse(), true);
            tRight = concat$1(tRight, r.reverse(), true);
          } else if (typeLeft === "object") {
            const [l, r] = diffObject$1(arrLeft[i - 1], arrRight[j - 1], level + 2, options, diffArrayLCS);
            tLeft.unshift({
              level: level + 1,
              type: "equal",
              text: "}"
            });
            tRight.unshift({
              level: level + 1,
              type: "equal",
              text: "}"
            });
            tLeft = concat$1(tLeft, l.reverse(), true);
            tRight = concat$1(tRight, r.reverse(), true);
            tLeft.unshift({
              level: level + 1,
              type: "equal",
              text: "{"
            });
            tRight.unshift({
              level: level + 1,
              type: "equal",
              text: "{"
            });
          } else {
            tLeft.unshift({
              level: level + 1,
              type: "modify",
              text: formatValue$1(arrLeft[i - 1], void 0, void 0, options.undefinedBehavior)
            });
            tRight.unshift({
              level: level + 1,
              type: "modify",
              text: formatValue$1(arrRight[j - 1], void 0, void 0, options.undefinedBehavior)
            });
          }
        } else {
          const reversedLeft = [];
          const reversedRight = [];
          prettyAppendLines$1(reversedLeft, reversedRight, "", "", arrLeft[i - 1], arrRight[j - 1], level + 1, options);
          tLeft = concat$1(tLeft, reversedLeft.reverse(), true);
          tRight = concat$1(tRight, reversedRight.reverse(), true);
        }
        i--;
        j--;
      } else {
        const removedLines = stringify$1(arrLeft[i - 1], void 0, 1, void 0, options.undefinedBehavior).split("\n");
        for (let i2 = removedLines.length - 1; i2 >= 0; i2--) {
          tLeft.unshift({
            level: level + 1 + (((_b = (_a = removedLines[i2].match(/^\s+/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0),
            type: "remove",
            text: removedLines[i2].replace(/^\s+/, "").replace(/,$/g, "")
          });
          tRight.unshift({
            level: level + 1,
            type: "equal",
            text: ""
          });
        }
        i--;
      }
    } else {
      const addedLines = stringify$1(arrRight[j - 1], void 0, 1, void 0, options.undefinedBehavior).split("\n");
      for (let i2 = addedLines.length - 1; i2 >= 0; i2--) {
        tLeft.unshift({
          level: level + 1,
          type: "equal",
          text: ""
        });
        tRight.unshift({
          level: level + 1 + (((_d = (_c = addedLines[i2].match(/^\s+/)) == null ? void 0 : _c[0]) == null ? void 0 : _d.length) || 0),
          type: "add",
          text: addedLines[i2].replace(/^\s+/, "").replace(/,$/g, "")
        });
      }
      j--;
    }
  }
  return [
    tLeft,
    tRight
  ];
};
var diffArrayLCS = (arrLeft, arrRight, keyLeft, keyRight, level, options, linesLeft = [], linesRight = []) => {
  if (keyLeft && keyRight) {
    linesLeft.push({
      level,
      type: "equal",
      text: `"${keyLeft}": [`
    });
    linesRight.push({
      level,
      type: "equal",
      text: `"${keyRight}": [`
    });
  } else {
    linesLeft.push({
      level,
      type: "equal",
      text: "["
    });
    linesRight.push({
      level,
      type: "equal",
      text: "["
    });
  }
  if (level >= (options.maxDepth || Infinity)) {
    linesLeft.push({
      level: level + 1,
      type: "equal",
      text: "..."
    });
    linesRight.push({
      level: level + 1,
      type: "equal",
      text: "..."
    });
  } else {
    const [tLeftReverse, tRightReverse] = lcs(arrLeft, arrRight, keyLeft, keyRight, level, options);
    linesLeft = concat$1(linesLeft, tLeftReverse);
    linesRight = concat$1(linesRight, tRightReverse);
  }
  linesLeft.push({
    level,
    type: "equal",
    text: "]"
  });
  linesRight.push({
    level,
    type: "equal",
    text: "]"
  });
  return [
    linesLeft,
    linesRight
  ];
};
var diffArrayLCS$1 = diffArrayLCS;
var diffArrayNormal = (arrLeft, arrRight, keyLeft, keyRight, level, options, linesLeft = [], linesRight = []) => {
  var _a, _b, _c, _d;
  arrLeft = [
    ...arrLeft
  ];
  arrRight = [
    ...arrRight
  ];
  if (keyLeft && keyRight) {
    linesLeft.push({
      level,
      type: "equal",
      text: `"${keyLeft}": [`
    });
    linesRight.push({
      level,
      type: "equal",
      text: `"${keyRight}": [`
    });
  } else {
    linesLeft.push({
      level,
      type: "equal",
      text: "["
    });
    linesRight.push({
      level,
      type: "equal",
      text: "["
    });
  }
  if (level >= (options.maxDepth || Infinity)) {
    linesLeft.push({
      level: level + 1,
      type: "equal",
      text: "..."
    });
    linesRight.push({
      level: level + 1,
      type: "equal",
      text: "..."
    });
  } else {
    while (arrLeft.length || arrRight.length) {
      const itemLeft = arrLeft[0];
      const itemRight = arrRight[0];
      const leftType = getType$1(itemLeft);
      const rightType = getType$1(itemRight);
      if (arrLeft.length && arrRight.length) {
        if (leftType !== rightType) {
          prettyAppendLines$1(linesLeft, linesRight, "", "", itemLeft, itemRight, level + 1, options);
        } else if (options.recursiveEqual && [
          "object",
          "array"
        ].includes(leftType) && isEqual$1(itemLeft, itemRight, options)) {
          prettyAppendLines$1(linesLeft, linesRight, "", "", itemLeft, itemRight, level + 1, options);
        } else if (leftType === "object") {
          linesLeft.push({
            level: level + 1,
            type: "equal",
            text: "{"
          });
          linesRight.push({
            level: level + 1,
            type: "equal",
            text: "{"
          });
          const [leftLines, rightLines] = diffObject$1(itemLeft, itemRight, level + 2, options, diffArrayNormal);
          linesLeft = concat$1(linesLeft, leftLines);
          linesRight = concat$1(linesRight, rightLines);
          linesLeft.push({
            level: level + 1,
            type: "equal",
            text: "}"
          });
          linesRight.push({
            level: level + 1,
            type: "equal",
            text: "}"
          });
        } else if (leftType === "array") {
          const [resLeft, resRight] = diffArrayNormal(itemLeft, itemRight, "", "", level + 1, options, [], []);
          linesLeft = concat$1(linesLeft, resLeft);
          linesRight = concat$1(linesRight, resRight);
        } else if (cmp$1(itemLeft, itemRight, {
          ignoreCase: options.ignoreCase
        }) === 0) {
          linesLeft.push({
            level: level + 1,
            type: "equal",
            text: formatValue$1(itemLeft, void 0, void 0, options.undefinedBehavior)
          });
          linesRight.push({
            level: level + 1,
            type: "equal",
            text: formatValue$1(itemRight, void 0, void 0, options.undefinedBehavior)
          });
        } else {
          if (options.showModifications) {
            linesLeft.push({
              level: level + 1,
              type: "modify",
              text: formatValue$1(itemLeft, void 0, void 0, options.undefinedBehavior)
            });
            linesRight.push({
              level: level + 1,
              type: "modify",
              text: formatValue$1(itemRight, void 0, void 0, options.undefinedBehavior)
            });
          } else {
            linesLeft.push({
              level: level + 1,
              type: "remove",
              text: formatValue$1(itemLeft, void 0, void 0, options.undefinedBehavior)
            });
            linesLeft.push({
              level: level + 1,
              type: "equal",
              text: ""
            });
            linesRight.push({
              level: level + 1,
              type: "equal",
              text: ""
            });
            linesRight.push({
              level: level + 1,
              type: "add",
              text: formatValue$1(itemRight, void 0, void 0, options.undefinedBehavior)
            });
          }
        }
        arrLeft.shift();
        arrRight.shift();
      } else if (arrLeft.length) {
        const removedLines = formatValue$1(itemLeft, void 0, true, options.undefinedBehavior).split("\n");
        for (let i = 0; i < removedLines.length; i++) {
          linesLeft.push({
            level: level + 1 + (((_b = (_a = removedLines[i].match(/^\s+/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0),
            type: "remove",
            text: removedLines[i].replace(/^\s+/, "").replace(/,$/g, "")
          });
          linesRight.push({
            level: level + 1,
            type: "equal",
            text: ""
          });
        }
        arrLeft.shift();
      } else if (arrRight.length) {
        const addedLines = formatValue$1(itemRight, void 0, true, options.undefinedBehavior).split("\n");
        for (let i = 0; i < addedLines.length; i++) {
          linesLeft.push({
            level: level + 1,
            type: "equal",
            text: ""
          });
          linesRight.push({
            level: level + 1 + (((_d = (_c = addedLines[i].match(/^\s+/)) == null ? void 0 : _c[0]) == null ? void 0 : _d.length) || 0),
            type: "add",
            text: addedLines[i].replace(/^\s+/, "").replace(/,$/g, "")
          });
        }
        arrRight.shift();
      }
    }
  }
  linesLeft.push({
    level,
    type: "equal",
    text: "]"
  });
  linesRight.push({
    level,
    type: "equal",
    text: "]"
  });
  return [
    linesLeft,
    linesRight
  ];
};
var diffArrayNormal$1 = diffArrayNormal;
var sortInnerArrays = (source, options) => {
  if (!source || typeof source !== "object") {
    return source;
  }
  if (Array.isArray(source)) {
    const result2 = [
      ...source
    ];
    result2.sort((a, b) => cmp$1(a, b, {
      ignoreCase: options == null ? void 0 : options.ignoreCase
    }));
    return result2.map((item) => sortInnerArrays(item, options));
  }
  const result = {
    ...source
  };
  for (const key in result) {
    result[key] = sortInnerArrays(result[key], options);
  }
  return result;
};
var sortInnerArrays$1 = sortInnerArrays;
var UndefinedBehavior;
(function(UndefinedBehavior2) {
  UndefinedBehavior2["stringify"] = "stringify";
  UndefinedBehavior2["ignore"] = "ignore";
  UndefinedBehavior2["throw"] = "throw";
})(UndefinedBehavior || (UndefinedBehavior = {}));
var EQUAL_EMPTY_LINE = {
  level: 0,
  type: "equal",
  text: ""
};
var EQUAL_LEFT_BRACKET_LINE = {
  level: 0,
  type: "equal",
  text: "{"
};
var EQUAL_RIGHT_BRACKET_LINE = {
  level: 0,
  type: "equal",
  text: "}"
};
var Differ = class Differ2 {
  detectCircular(source) {
    if (this.options.detectCircular) {
      if (detectCircular$1(source)) {
        throw new Error(`Circular reference detected in object (with keys ${Object.keys(source).map((t) => `"${t}"`).join(", ")})`);
      }
    }
  }
  sortResultLines(left, right) {
    for (let k = 0; k < left.length; k++) {
      let changed = false;
      for (let i = 1; i < left.length; i++) {
        if (left[i].type === "remove" && left[i - 1].type === "equal" && right[i].type === "equal" && right[i - 1].type === "add") {
          const t1 = left[i - 1];
          left[i - 1] = left[i];
          left[i] = t1;
          const t2 = right[i - 1];
          right[i - 1] = right[i];
          right[i] = t2;
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
  }
  calculateLineNumbers(result) {
    let lineNumber = 0;
    for (const item of result) {
      if (!item.text) {
        continue;
      }
      item.lineNumber = ++lineNumber;
    }
  }
  calculateCommas(result) {
    const nextLine = Array(result.length).fill(0);
    for (let i = result.length - 1; i > 0; i--) {
      if (result[i].text) {
        nextLine[i - 1] = i;
      } else {
        nextLine[i - 1] = nextLine[i];
      }
    }
    for (let i = 0; i < result.length; i++) {
      if (!result[i].text.endsWith("{") && !result[i].text.endsWith("[") && result[i].text && nextLine[i] && result[i].level <= result[nextLine[i]].level) {
        result[i].comma = true;
      }
    }
  }
  diff(sourceLeft, sourceRight) {
    this.detectCircular(sourceLeft);
    this.detectCircular(sourceRight);
    if (this.options.arrayDiffMethod === "unorder-normal" || this.options.arrayDiffMethod === "unorder-lcs") {
      sourceLeft = sortInnerArrays$1(sourceLeft, this.options);
      sourceRight = sortInnerArrays$1(sourceRight, this.options);
    }
    if (this.options.undefinedBehavior === "ignore") {
      sourceLeft = cleanFields$1(sourceLeft) ?? null;
      sourceRight = cleanFields$1(sourceRight) ?? null;
    }
    let resultLeft = [];
    let resultRight = [];
    const typeLeft = getType$1(sourceLeft);
    const typeRight = getType$1(sourceRight);
    if (typeLeft !== typeRight) {
      const strLeft = stringify$1(sourceLeft, void 0, 1, this.options.maxDepth, this.options.undefinedBehavior);
      resultLeft = strLeft.split("\n").map((line) => {
        var _a, _b;
        return {
          level: ((_b = (_a = line.match(/^\s+/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0,
          type: "remove",
          text: line.replace(/^\s+/, "").replace(/,$/g, ""),
          comma: line.endsWith(",")
        };
      });
      const strRight = stringify$1(sourceRight, void 0, 1, this.options.maxDepth, this.options.undefinedBehavior);
      resultRight = strRight.split("\n").map((line) => {
        var _a, _b;
        return {
          level: ((_b = (_a = line.match(/^\s+/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0,
          type: "add",
          text: line.replace(/^\s+/, "").replace(/,$/g, ""),
          comma: line.endsWith(",")
        };
      });
      const lLength = resultLeft.length;
      const rLength = resultRight.length;
      resultLeft = concat$1(resultLeft, Array(rLength).fill(0).map(() => ({
        ...EQUAL_EMPTY_LINE
      })));
      resultRight = concat$1(resultRight, Array(lLength).fill(0).map(() => ({
        ...EQUAL_EMPTY_LINE
      })), true);
    } else if (typeLeft === "object") {
      [resultLeft, resultRight] = diffObject$1(sourceLeft, sourceRight, 1, this.options, this.arrayDiffFunc);
      resultLeft.unshift({
        ...EQUAL_LEFT_BRACKET_LINE
      });
      resultLeft.push({
        ...EQUAL_RIGHT_BRACKET_LINE
      });
      resultRight.unshift({
        ...EQUAL_LEFT_BRACKET_LINE
      });
      resultRight.push({
        ...EQUAL_RIGHT_BRACKET_LINE
      });
    } else if (typeLeft === "array") {
      [resultLeft, resultRight] = this.arrayDiffFunc(sourceLeft, sourceRight, "", "", 0, this.options);
    } else if (sourceLeft !== sourceRight) {
      if (this.options.ignoreCase) {
        if (typeof sourceLeft === "string" && typeof sourceRight === "string" && sourceLeft.toLowerCase() === sourceRight.toLowerCase()) {
          resultLeft = [
            {
              level: 0,
              type: "equal",
              text: sourceLeft
            }
          ];
          resultRight = [
            {
              level: 0,
              type: "equal",
              text: sourceRight
            }
          ];
        }
      } else if (this.options.showModifications) {
        resultLeft = [
          {
            level: 0,
            type: "modify",
            text: stringify$1(sourceLeft, void 0, void 0, this.options.maxDepth, this.options.undefinedBehavior)
          }
        ];
        resultRight = [
          {
            level: 0,
            type: "modify",
            text: stringify$1(sourceRight, void 0, void 0, this.options.maxDepth, this.options.undefinedBehavior)
          }
        ];
      } else {
        resultLeft = [
          {
            level: 0,
            type: "remove",
            text: stringify$1(sourceLeft, void 0, void 0, this.options.maxDepth, this.options.undefinedBehavior)
          },
          {
            ...EQUAL_EMPTY_LINE
          }
        ];
        resultRight = [
          {
            ...EQUAL_EMPTY_LINE
          },
          {
            level: 0,
            type: "add",
            text: stringify$1(sourceRight, void 0, void 0, this.options.maxDepth, this.options.undefinedBehavior)
          }
        ];
      }
    } else {
      resultLeft = [
        {
          level: 0,
          type: "equal",
          text: stringify$1(sourceLeft, void 0, void 0, this.options.maxDepth, this.options.undefinedBehavior)
        }
      ];
      resultRight = [
        {
          level: 0,
          type: "equal",
          text: stringify$1(sourceRight, void 0, void 0, this.options.maxDepth, this.options.undefinedBehavior)
        }
      ];
    }
    this.sortResultLines(resultLeft, resultRight);
    this.calculateLineNumbers(resultLeft);
    this.calculateLineNumbers(resultRight);
    this.calculateCommas(resultLeft);
    this.calculateCommas(resultRight);
    return [
      resultLeft,
      resultRight
    ];
  }
  constructor({ detectCircular: detectCircular2 = true, maxDepth = Infinity, showModifications = true, arrayDiffMethod = "normal", ignoreCase = false, ignoreCaseForKey = false, recursiveEqual = false, preserveKeyOrder, undefinedBehavior = "stringify" } = {}) {
    this.options = {
      detectCircular: detectCircular2,
      maxDepth,
      showModifications,
      arrayDiffMethod,
      ignoreCase,
      ignoreCaseForKey,
      recursiveEqual,
      preserveKeyOrder,
      undefinedBehavior
    };
    this.arrayDiffFunc = arrayDiffMethod === "lcs" || arrayDiffMethod === "unorder-lcs" ? diffArrayLCS$1 : diffArrayNormal$1;
  }
};

// node_modules/json-diff-kit/dist/viewer.js
var React = __toESM(require_react());
var isExpandLine = (segment) => {
  return "hasLinesBefore" in segment || "hasLinesAfter" in segment;
};
var getSegmentHeight = (segment, itemHeight, expandLineHeight) => {
  return isExpandLine(segment) ? expandLineHeight : itemHeight * (segment.end - segment.start + 1);
};
var mergeSegments = (tokens, diffs) => {
  const result = [];
  let token;
  let diff2;
  if (tokens.length && diffs.length) {
    tokens = [
      ...tokens
    ];
    diffs = [
      ...diffs
    ];
    token = {
      ...tokens.shift()
    };
    diff2 = {
      ...diffs.shift()
    };
    while (1) {
      if (token.start === diff2.start) {
        const end = Math.min(token.end, diff2.end);
        result.push({
          ...token,
          ...diff2,
          end
        });
        token.start = diff2.start = end;
      } else if (token.start < diff2.start) {
        const end = Math.min(token.end, diff2.start);
        result.push({
          ...diff2,
          ...token,
          end
        });
        token.start = end;
      } else {
        const end = Math.min(token.start, diff2.end);
        result.push({
          ...token,
          ...diff2,
          end
        });
        diff2.start = end;
      }
      if (!tokens.length || !diffs.length) break;
      if (token.start === token.end) token = {
        ...tokens.shift()
      };
      if (diff2.start === diff2.end) diff2 = {
        ...diffs.shift()
      };
    }
  }
  if (!tokens.length) result.push(...diffs.map((d) => ({
    ...d,
    token: token.token || "plain"
  })));
  if (!diffs.length) result.push(...tokens);
  return result;
};
var calculatePlaceholderHeight = (segments, accTop, startSegment, startLine, endSegment, endLine, itemHeight, expandLineHeight, totalHeight) => {
  if (!accTop.length) {
    return [
      0,
      0
    ];
  }
  let topHeight = 0;
  let bottomHeight = 0;
  const startSegmentItem = segments[startSegment];
  if (isExpandLine(startSegmentItem)) {
    topHeight = accTop[startSegment];
  } else {
    topHeight = accTop[startSegment] + (startLine - startSegmentItem.start) * itemHeight;
  }
  const endSegmentItem = segments[endSegment];
  if (isExpandLine(endSegmentItem)) {
    bottomHeight = totalHeight - accTop[endSegment] - expandLineHeight;
  } else {
    bottomHeight = totalHeight - accTop[endSegment] - (endLine - endSegmentItem.start) * itemHeight;
  }
  return [
    topHeight,
    bottomHeight
  ];
};
var calculatePlaceholderHeight$1 = calculatePlaceholderHeight;
var findVisibleLines = (segments, accTop, viewportTop, viewportBottom, itemHeight, expandLineHeight) => {
  if (!accTop.length) {
    return [
      0,
      0,
      0,
      0
    ];
  }
  let startSegment = 0;
  let endSegment = 0;
  let startLine = 0;
  let endLine = 0;
  let l = 0;
  let r = segments.length - 1;
  while (1) {
    const m = Math.floor((l + r) / 2);
    const top = accTop[m];
    const bottom = top + getSegmentHeight(segments[m], itemHeight, expandLineHeight);
    if (bottom <= viewportTop) {
      l = m + 1;
    } else {
      r = m;
    }
    if (l === r) {
      startSegment = l;
      break;
    }
  }
  const startSegmentItem = segments[startSegment];
  if (isExpandLine(startSegmentItem)) {
    startLine = startSegmentItem.start;
  } else {
    startLine = startSegmentItem.start + Math.floor((viewportTop - accTop[startSegment]) / itemHeight);
  }
  l = 0;
  r = segments.length - 1;
  while (1) {
    const m = Math.floor((l + r + 1) / 2);
    const top = accTop[m];
    if (top >= viewportBottom) {
      r = m - 1;
    } else {
      l = m;
    }
    if (l === r) {
      endSegment = l;
      break;
    }
  }
  const endSegmentItem = segments[endSegment];
  if (isExpandLine(endSegmentItem)) {
    endLine = endSegmentItem.end;
  } else {
    endLine = endSegmentItem.start + Math.ceil((viewportBottom - accTop[endSegment]) / itemHeight);
  }
  return [
    startSegment,
    startLine,
    endSegment,
    endLine
  ];
};
var findVisibleLines$1 = findVisibleLines;
var bin = {};
Object.defineProperty(bin, "__esModule", {
  value: true
});
bin.applyPatch = bin.calcPatch = lcs_1 = bin.lcs = bin.diff = bin.diff_core = void 0;
function diff_internal(state, c) {
  const { b, eq: eq2, stack_base } = state;
  let { i, N, j, M, Z, stack_top } = state;
  for (; ; ) {
    switch (c) {
      case 0: {
        Z_block: while (N > 0 && M > 0) {
          b.fill(0, 0, 2 * Z);
          const W = N - M;
          const L = N + M;
          const parity = L & 1;
          const offsetx = i + N - 1;
          const offsety = j + M - 1;
          const hmax = (L + parity) / 2;
          let z;
          h_loop: for (let h = 0; h <= hmax; h++) {
            const kmin = 2 * Math.max(0, h - M) - h;
            const kmax = h - 2 * Math.max(0, h - N);
            for (let k = kmin; k <= kmax; k += 2) {
              const gkm = b[k - 1 - Z * Math.floor((k - 1) / Z)];
              const gkp = b[k + 1 - Z * Math.floor((k + 1) / Z)];
              const u = k === -h || k !== h && gkm < gkp ? gkp : gkm + 1;
              const v = u - k;
              let x = u;
              let y = v;
              while (x < N && y < M && eq2(i + x, j + y)) x++, y++;
              b[k - Z * Math.floor(k / Z)] = x;
              if (parity === 1 && (z = W - k) >= 1 - h && z < h && x + b[Z + z - Z * Math.floor(z / Z)] >= N) {
                if (h > 1 || x !== u) {
                  stack_base[stack_top++] = i + x;
                  stack_base[stack_top++] = N - x;
                  stack_base[stack_top++] = j + y;
                  stack_base[stack_top++] = M - y;
                  N = u;
                  M = v;
                  Z = 2 * (Math.min(N, M) + 1);
                  continue Z_block;
                } else break h_loop;
              }
            }
            for (let k = kmin; k <= kmax; k += 2) {
              const pkm = b[Z + k - 1 - Z * Math.floor((k - 1) / Z)];
              const pkp = b[Z + k + 1 - Z * Math.floor((k + 1) / Z)];
              const u = k === -h || k !== h && pkm < pkp ? pkp : pkm + 1;
              const v = u - k;
              let x = u;
              let y = v;
              while (x < N && y < M && eq2(offsetx - x, offsety - y)) x++, y++;
              b[Z + k - Z * Math.floor(k / Z)] = x;
              if (parity === 0 && (z = W - k) >= -h && z <= h && x + b[z - Z * Math.floor(z / Z)] >= N) {
                if (h > 0 || x !== u) {
                  stack_base[stack_top++] = i + N - u;
                  stack_base[stack_top++] = u;
                  stack_base[stack_top++] = j + M - v;
                  stack_base[stack_top++] = v;
                  N = N - x;
                  M = M - y;
                  Z = 2 * (Math.min(N, M) + 1);
                  continue Z_block;
                } else break h_loop;
              }
            }
          }
          if (N === M) continue;
          if (M > N) {
            i += N;
            j += N;
            M -= N;
            N = 0;
          } else {
            i += M;
            j += M;
            N -= M;
            M = 0;
          }
          break;
        }
        if (N + M !== 0) {
          if (state.pxe === i || state.pye === j) {
            state.pxe = i + N;
            state.pye = j + M;
          } else {
            const sx = state.pxs;
            state.oxs = state.pxs;
            state.oxe = state.pxe;
            state.oys = state.pys;
            state.oye = state.pye;
            state.pxs = i;
            state.pxe = i + N;
            state.pys = j;
            state.pye = j + M;
            if (sx >= 0) {
              state.i = i;
              state.N = N;
              state.j = j;
              state.M = M;
              state.Z = Z;
              state.stack_top = stack_top;
              return 1;
            }
          }
        }
      }
      case 1: {
        if (stack_top === 0) return 2;
        M = stack_base[--stack_top];
        j = stack_base[--stack_top];
        N = stack_base[--stack_top];
        i = stack_base[--stack_top];
        Z = 2 * (Math.min(N, M) + 1);
        c = 0;
      }
    }
  }
}
var DiffGen = class DiffGen2 {
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const { state, result } = this;
    if (this.c > 1) {
      result.done = true;
      result.value = void 0;
      return result;
    }
    const c = diff_internal(state, this.c);
    this.c = c;
    if (c === 1) {
      result.value = [
        state.oxs,
        state.oxe,
        state.oys,
        state.oye
      ];
      return result;
    }
    if (state.pxs >= 0) {
      result.value = [
        state.pxs,
        state.pxe,
        state.pys,
        state.pye
      ];
      return result;
    }
    result.done = true;
    result.value = void 0;
    return result;
  }
  constructor(state) {
    this.state = state;
    this.c = 0;
    this.result = {
      value: null,
      done: false
    };
  }
};
function diff_core(i, N, j, M, eq2) {
  const Z = (Math.min(N, M) + 1) * 2;
  const L = N + M;
  const b = new (L < 256 ? Uint8Array : L < 65536 ? Uint16Array : Uint32Array)(2 * Z);
  return new DiffGen({
    i,
    N,
    j,
    M,
    Z,
    b,
    eq: eq2,
    pxs: -1,
    pxe: -1,
    pys: -1,
    pye: -1,
    oxs: -1,
    oxe: -1,
    oys: -1,
    oye: -1,
    stack_top: 0,
    stack_base: []
  });
}
bin.diff_core = diff_core;
function diff(xs, ys) {
  let [i, N, M] = [
    0,
    xs.length,
    ys.length
  ];
  while (i < N && i < M && xs[i] === ys[i]) i++;
  if (i === N && i === M) return [][Symbol.iterator]();
  while (xs[--N] === ys[--M] && N > i && M > i) ;
  const eq2 = (x, y) => xs[x] === ys[y];
  return diff_core(i, N + 1 - i, i, M + 1 - i, eq2);
}
bin.diff = diff;
var LCSGen = class LCSGen2 {
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const rec = this.diff.next();
    if (rec.done) {
      const { i: i2, j: j2, N } = this;
      if (i2 < N) {
        rec.done = false;
        rec.value = [
          i2,
          j2,
          N - i2
        ];
        this.i = N;
      }
      return rec;
    }
    const v = rec.value;
    const sx = v[0];
    const ex = v[1];
    const ey = v[3];
    const { i, j } = this;
    if (i !== sx) {
      v.length--;
      v[0] = i;
      v[1] = j;
      v[2] = sx - i;
    }
    this.i = ex;
    this.j = ey;
    return rec;
  }
  constructor(diff2, N) {
    this.diff = diff2;
    this.N = N;
    this.i = 0;
    this.j = 0;
  }
};
function lcs2(xs, ys) {
  return new LCSGen(diff(xs, ys), xs.length);
}
var lcs_1 = bin.lcs = lcs2;
function* calcPatch(xs, ys) {
  const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
  for (const v of diff(xs, ys)) {
    v[2] = slice.call(ys, v[2], v[3]);
    yield v;
  }
}
bin.calcPatch = calcPatch;
function* applyPatch(xs, patch) {
  let i = 0;
  const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
  for (const [dels, dele, ins] of patch) {
    if (i < dels) yield slice.call(xs, i, dels);
    if (ins.length > 0) yield ins;
    i = dele;
  }
  if (i < xs.length) yield slice.call(xs, i);
}
bin.applyPatch = applyPatch;
var getOriginalIndices = (arr, separatorLength) => {
  const result = [];
  let index = 0;
  for (const item of arr) {
    result.push(index);
    index += item.length + separatorLength;
  }
  result.push(index - separatorLength);
  return result;
};
var filterEmptyParts = (arr) => {
  return arr.filter((item) => item.end > item.start);
};
var getInlineDiff = (l, r, options) => {
  let resultL = [];
  let resultR = [];
  let lastL = 0;
  let lastR = 0;
  if (options.mode === "word") {
    const wordSeparator = options.wordSeparator || " ";
    const lArr = l.split(wordSeparator);
    const rArr = r.split(wordSeparator);
    const iter2 = [
      ...lcs_1(lArr, rArr)
    ];
    const separatorLength = wordSeparator.length;
    const indicesL = getOriginalIndices(lArr, separatorLength);
    const indicesR = getOriginalIndices(rArr, separatorLength);
    for (const [sl, sr, length] of iter2) {
      if (sl > lastL) {
        resultL.push({
          type: "remove",
          start: indicesL[lastL],
          end: indicesL[sl]
        });
      }
      if (sr > lastR) {
        resultR.push({
          type: "add",
          start: indicesR[lastR],
          end: indicesR[sr]
        });
      }
      lastL = sl + length;
      lastR = sr + length;
      resultL.push({
        start: indicesL[sl],
        end: indicesL[lastL]
      });
      resultR.push({
        start: indicesR[sr],
        end: indicesR[lastR]
      });
    }
    if (l.length > lastL) {
      resultL.push({
        type: "remove",
        start: indicesL[lastL],
        end: l.length
      });
    }
    if (r.length > lastR) {
      resultR.push({
        type: "add",
        start: indicesR[lastR],
        end: r.length
      });
    }
    resultL = filterEmptyParts(resultL);
    resultR = filterEmptyParts(resultR);
    return [
      resultL,
      resultR
    ];
  }
  const iter = lcs_1(l, r);
  for (const [sl, sr, length] of iter) {
    if (sl > lastL) {
      resultL.push({
        type: "remove",
        start: lastL,
        end: sl
      });
    }
    if (sr > lastR) {
      resultR.push({
        type: "add",
        start: lastR,
        end: sr
      });
    }
    lastL = sl + length;
    lastR = sr + length;
    resultL.push({
      start: sl,
      end: lastL
    });
    resultR.push({
      start: sr,
      end: lastR
    });
  }
  if (l.length > lastL) {
    resultL.push({
      type: "remove",
      start: lastL,
      end: l.length
    });
  }
  if (r.length > lastR) {
    resultR.push({
      type: "add",
      start: lastR,
      end: r.length
    });
  }
  resultL = filterEmptyParts(resultL);
  resultR = filterEmptyParts(resultR);
  return [
    resultL,
    resultR
  ];
};
var getInlineDiff$1 = getInlineDiff;
var syntaxHighlightLine = (enabled, text, offset) => {
  if (!enabled) {
    return [
      {
        token: "plain",
        start: offset,
        end: text.length + offset
      }
    ];
  }
  if (text === "undefined" || text === "Infinity" || text === "-Infinity" || text === "NaN" || /^\d+n$/i.test(text) || text.startsWith("Symbol(") || text.startsWith("function") || text.startsWith("(")) {
    return [
      {
        token: "invalid",
        start: offset,
        end: text.length + offset
      }
    ];
  }
  if (!Number.isNaN(Number(text))) {
    return [
      {
        token: "number",
        start: offset,
        end: text.length + offset
      }
    ];
  }
  if (text === "true" || text === "false") {
    return [
      {
        token: "boolean",
        start: offset,
        end: text.length + offset
      }
    ];
  }
  if (text === "null") {
    return [
      {
        token: "null",
        start: offset,
        end: text.length + offset
      }
    ];
  }
  if (text.startsWith('"')) {
    if (text.endsWith(": [") || text.endsWith(": {")) {
      return [
        {
          token: "key",
          start: offset,
          end: text.length - 3 + offset
        },
        {
          token: "punctuation",
          start: text.length - 3,
          end: text.length - 2 + offset
        },
        {
          token: "plain",
          start: text.length - 2,
          end: text.length - 1 + offset
        },
        {
          token: "punctuation",
          start: text.length - 1,
          end: text.length + offset
        }
      ];
    }
    let pairedQuoteIndex = 1;
    while (pairedQuoteIndex < text.length) {
      if (text[pairedQuoteIndex] === '"') break;
      if (text[pairedQuoteIndex] === "\\") ++pairedQuoteIndex;
      ++pairedQuoteIndex;
    }
    if (pairedQuoteIndex === text.length - 1) {
      return [
        {
          token: "string",
          start: offset,
          end: text.length + offset
        }
      ];
    }
    return [
      {
        token: "key",
        start: offset,
        end: pairedQuoteIndex + 1 + offset
      },
      {
        token: "punctuation",
        start: pairedQuoteIndex + 1,
        end: pairedQuoteIndex + 2 + offset
      },
      {
        token: "plain",
        start: pairedQuoteIndex + 2,
        end: pairedQuoteIndex + 3 + offset
      },
      ...syntaxHighlightLine(enabled, text.substring(pairedQuoteIndex + 3), offset + pairedQuoteIndex + 3)
    ];
  }
  if (text === "{" || text === "}" || text === "[" || text === "]") {
    return [
      {
        token: "punctuation",
        start: offset,
        end: text.length + offset
      }
    ];
  }
  return [
    {
      token: "plain",
      start: offset,
      end: text.length + offset
    }
  ];
};
var getInlineSyntaxHighlight = syntaxHighlightLine;
var defaultOptions = {
  threshold: 8,
  margin: 3
};
var getSegments = (l, r, options, jsonsAreEqual) => {
  if (!options || jsonsAreEqual) {
    return [
      {
        start: 0,
        end: l.length,
        isEqual: false
      }
    ];
  }
  const segments = [];
  for (let i = 0; i < l.length; i++) {
    if (l[i].type === "equal" && r[i].type === "equal") {
      if (segments.length && segments[segments.length - 1].isEqual) {
        segments[segments.length - 1].end++;
      } else {
        segments.push({
          start: i,
          end: i + 1,
          isEqual: true
        });
      }
    } else {
      if (segments.length && !segments[segments.length - 1].isEqual) {
        segments[segments.length - 1].end++;
      } else {
        segments.push({
          start: i,
          end: i + 1,
          isEqual: false
        });
      }
    }
  }
  const _options = options === true ? defaultOptions : {
    ...defaultOptions,
    ...options
  };
  const { threshold, margin } = _options;
  if (threshold < margin * 2 + 1) {
    console.warn(`Threshold (${threshold}) is no more than 2 margins + 1 "expand" line (${margin} * 2 + 1), it's not necessary to hide unchanged areas which have less than ${margin * 2 + 1} lines.`);
  }
  const result = [];
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (!segment.isEqual || segment.end - segment.start < threshold || segment.end - segment.start <= margin * 2 + 1) {
      result.push(segment);
      continue;
    }
    if (!i) {
      result.push({
        hasLinesBefore: true,
        hasLinesAfter: false,
        start: 0,
        end: segment.end - margin,
        isEqual: true
      });
      result.push({
        start: segment.end - margin,
        end: segment.end,
        isEqual: true
      });
    } else if (i === segments.length - 1) {
      result.push({
        start: segment.start,
        end: segment.start + margin,
        isEqual: true
      });
      result.push({
        hasLinesBefore: false,
        hasLinesAfter: true,
        start: segment.start + margin,
        end: l.length,
        isEqual: true
      });
    } else {
      result.push({
        start: segment.start,
        end: segment.start + margin,
        isEqual: true
      });
      result.push({
        hasLinesBefore: true,
        hasLinesAfter: true,
        start: segment.start + margin,
        end: segment.end - margin,
        isEqual: true
      });
      result.push({
        start: segment.end - margin,
        end: segment.end,
        isEqual: true
      });
    }
  }
  return result;
};
var getSegments$1 = getSegments;
var DEFAULT_INDENT = 2;
var DEFAULT_EXPAND_MORE_LINES_LIMIT = 20;
var DEFAULT_TEXTS = {
  noChangeDetected: "No change detected"
};
var Viewer = (props) => {
  var _a, _b;
  const [linesLeft, linesRight] = props.diff;
  const jsonsAreEqual = React.useMemo(() => {
    return linesLeft.length === linesRight.length && linesLeft.every((item) => item.type === "equal") && linesRight.every((item) => item.type === "equal");
  }, [
    linesLeft,
    linesRight
  ]);
  const mergedTexts = {
    ...DEFAULT_TEXTS,
    ...props.texts
  };
  const lineNumberWidth = props.lineNumbers ? `calc(${String(linesLeft.length).length}ch + 16px)` : 0;
  const indent = props.indent ?? DEFAULT_INDENT;
  const indentChar = indent === "tab" ? "	" : " ";
  const indentSize = indent === "tab" ? 1 : indent;
  const inlineDiffOptions = {
    mode: ((_a = props.inlineDiffOptions) == null ? void 0 : _a.mode) || "char",
    wordSeparator: ((_b = props.inlineDiffOptions) == null ? void 0 : _b.wordSeparator) || ""
  };
  const hideUnchangedLines = props.hideUnchangedLines ?? false;
  const { scrollContainer: _scrollContainer = "body", itemHeight = 18, expandLineHeight = 26 } = !props.virtual || props.virtual === true ? {} : props.virtual;
  const scrollContainer = _scrollContainer === "body" ? document.body : document.querySelector(_scrollContainer);
  const linesLeftRef = React.useRef(linesLeft);
  const linesRightRef = React.useRef(linesRight);
  const segmentsRef = React.useRef(getSegments$1(linesLeft, linesRight, hideUnchangedLines, jsonsAreEqual));
  const accTopRef = React.useRef([]);
  const totalHeightRef = React.useRef(0);
  const tbodyRef = React.useRef(null);
  const [, forceUpdate] = React.useState({});
  const updateViewer = () => {
    accTopRef.current = [];
    if (props.virtual) {
      let acc = 0;
      for (const segment of segmentsRef.current) {
        if (isExpandLine(segment)) {
          accTopRef.current.push(acc);
          acc += expandLineHeight;
        } else {
          accTopRef.current.push(acc);
          acc += itemHeight * (segment.end - segment.start);
        }
      }
      totalHeightRef.current = segmentsRef.current.reduce((acc2, segment) => {
        if (!isExpandLine(segment)) {
          return acc2 + (segment.end - segment.start) * itemHeight;
        }
        return acc2 + expandLineHeight;
      }, 0);
    }
    forceUpdate({});
  };
  React.useEffect(() => {
    linesLeftRef.current = linesLeft;
    linesRightRef.current = linesRight;
    segmentsRef.current = getSegments$1(linesLeft, linesRight, hideUnchangedLines, jsonsAreEqual);
    updateViewer();
  }, [
    hideUnchangedLines,
    linesLeft,
    linesRight
  ]);
  React.useEffect(() => {
    if (!props.virtual || !scrollContainer) {
      return;
    }
    const onScroll = () => forceUpdate({});
    scrollContainer.addEventListener("scroll", onScroll);
    return () => {
      scrollContainer.removeEventListener("scroll", onScroll);
    };
  }, [
    props.virtual,
    scrollContainer
  ]);
  const onExpandBefore = (segmentIndex) => (lines) => {
    const newSegments = [
      ...segmentsRef.current
    ];
    const newSegment = newSegments[segmentIndex];
    newSegments[segmentIndex] = {
      ...newSegment,
      end: Math.max(newSegment.end - lines, newSegment.start)
    };
    if (segmentIndex + 1 < segmentsRef.current.length - 1) {
      newSegments[segmentIndex + 1] = {
        ...newSegments[segmentIndex + 1],
        start: Math.max(newSegment.end - lines, newSegment.start)
      };
    }
    segmentsRef.current = newSegments;
    updateViewer();
  };
  const onExpandAfter = (segmentIndex) => (lines) => {
    const newSegments = [
      ...segmentsRef.current
    ];
    const newSegment = newSegments[segmentIndex];
    newSegments[segmentIndex] = {
      ...newSegment,
      start: Math.min(newSegment.start + lines, newSegment.end)
    };
    if (segmentIndex > 1) {
      newSegments[segmentIndex - 1] = {
        ...newSegments[segmentIndex - 1],
        end: Math.min(newSegment.start + lines, newSegment.end)
      };
    }
    segmentsRef.current = newSegments;
    updateViewer();
  };
  const onExpandAll = (segmentIndex) => () => {
    const newSegments = [
      ...segmentsRef.current
    ];
    const newSegment = newSegments[segmentIndex];
    newSegments[segmentIndex] = {
      ...newSegment,
      start: newSegment.start,
      end: newSegment.start
    };
    if (segmentIndex + 1 < segmentsRef.current.length - 1) {
      newSegments[segmentIndex + 1] = {
        ...newSegments[segmentIndex + 1],
        start: newSegment.start
      };
    } else {
      newSegments[segmentIndex - 1] = {
        ...newSegments[segmentIndex - 1],
        end: newSegment.end
      };
    }
    segmentsRef.current = newSegments;
    updateViewer();
  };
  const renderInlineResult = (text, info = [], comma = false, syntaxHighlightEnabled2 = false) => React.createElement(React.Fragment, null, info.map((item, index) => {
    const frag = text.slice(item.start, item.end);
    if (!item.type && !item.token) {
      return frag;
    }
    const className = [
      item.type ? `inline-diff-${item.type}` : "",
      item.token ? `token ${item.token}` : ""
    ].filter(Boolean).join(" ");
    return React.createElement("span", {
      key: `${index}-${item.type}-${frag}`,
      className
    }, frag);
  }), comma && (syntaxHighlightEnabled2 ? React.createElement("span", {
    className: "token punctuation"
  }, ",") : ","));
  const renderLine = (index, syntaxHighlightEnabled2) => {
    var _a2, _b2;
    const l = linesLeftRef.current[index];
    const r = linesRightRef.current[index];
    const [lDiff, rDiff] = props.highlightInlineDiff && l.type === "modify" && r.type === "modify" ? getInlineDiff$1(l.text, r.text, inlineDiffOptions) : [
      [],
      []
    ];
    const lTokens = getInlineSyntaxHighlight(syntaxHighlightEnabled2, l.text, 0);
    const rTokens = getInlineSyntaxHighlight(syntaxHighlightEnabled2, r.text, 0);
    const lResult = mergeSegments(lTokens, lDiff);
    const rResult = mergeSegments(rTokens, rDiff);
    const bgLeft = l.type !== "equal" ? ((_a2 = props.bgColour) == null ? void 0 : _a2[l.type]) ?? "" : "";
    const bgRight = r.type !== "equal" ? ((_b2 = props.bgColour) == null ? void 0 : _b2[r.type]) ?? "" : "";
    return (
      // eslint-disable-next-line react/no-array-index-key
      React.createElement("tr", {
        key: index
      }, props.lineNumbers && React.createElement("td", {
        className: `line-${l.type} line-number`,
        style: {
          backgroundColor: bgLeft
        }
      }, l.lineNumber), React.createElement("td", {
        className: `line-${l.type}`,
        style: {
          backgroundColor: bgLeft
        }
      }, React.createElement("pre", null, l.text && indentChar.repeat(l.level * indentSize), renderInlineResult(l.text, lResult, l.comma, syntaxHighlightEnabled2))), props.lineNumbers && React.createElement("td", {
        className: `line-${r.type} line-number`,
        style: {
          backgroundColor: bgRight
        }
      }, r.lineNumber), React.createElement("td", {
        className: `line-${r.type}`,
        style: {
          backgroundColor: bgRight
        }
      }, React.createElement("pre", null, r.text && indentChar.repeat(r.level * indentSize), renderInlineResult(r.text, rResult, r.comma, syntaxHighlightEnabled2))))
    );
  };
  const renderExpandLine = (hasLinesBefore, hasLinesAfter, expandMoreLinesLimit, index) => {
    return React.createElement(React.Fragment, null, hasLinesBefore && React.createElement("button", {
      onClick: () => onExpandBefore(index)(expandMoreLinesLimit)
    }, "⭡ Show ", expandMoreLinesLimit, " lines before"), React.createElement("button", {
      onClick: () => onExpandAll(index)()
    }, "⭥ Show all unchanged lines"), hasLinesAfter && React.createElement("button", {
      onClick: () => onExpandAfter(index)(expandMoreLinesLimit)
    }, "⭣ Show ", expandMoreLinesLimit, " lines after"));
  };
  const renderSegment = (segment, index, renderStart, renderEnd, syntaxHighlightEnabled2) => {
    let { start, end } = segment;
    start = Math.max(start, renderStart);
    end = Math.min(end, renderEnd);
    if (start === end) {
      return null;
    }
    if (!isExpandLine(segment)) {
      return Array(end - start).fill(0).map((_, index2) => renderLine(start + index2, syntaxHighlightEnabled2));
    }
    const { hasLinesBefore, hasLinesAfter } = segment;
    const expandMoreLinesLimit = typeof hideUnchangedLines === "boolean" ? DEFAULT_EXPAND_MORE_LINES_LIMIT : hideUnchangedLines.expandMoreLinesLimit || DEFAULT_EXPAND_MORE_LINES_LIMIT;
    return [
      React.createElement("tr", {
        key: `expand-line-${index}`,
        className: "expand-line"
      }, React.createElement("td", {
        colSpan: 4,
        className: `${hasLinesBefore ? "has-lines-before" : ""} ${hasLinesAfter ? "has-lines-after" : ""}`
      }, typeof hideUnchangedLines !== "boolean" && hideUnchangedLines.expandLineRenderer ? hideUnchangedLines.expandLineRenderer({
        hasLinesBefore,
        hasLinesAfter,
        onExpandBefore: onExpandBefore(index),
        onExpandAfter: onExpandAfter(index),
        onExpandAll: onExpandAll(index)
      }) : renderExpandLine(hasLinesBefore, hasLinesAfter, expandMoreLinesLimit, index)))
    ];
  };
  const renderTbody = (syntaxHighlightEnabled2) => {
    if (jsonsAreEqual && hideUnchangedLines) {
      return React.createElement("tr", {
        key: "message-line",
        className: "message-line"
      }, React.createElement("td", {
        colSpan: 4
      }, mergedTexts.noChangeDetected));
    }
    if (!props.virtual) {
      return segmentsRef.current.map((item, index) => renderSegment(item, index, 0, linesLeftRef.current.length, syntaxHighlightEnabled2));
    }
    const containerHeight = (scrollContainer == null ? void 0 : scrollContainer.clientHeight) ?? 0;
    const scrollTop = (scrollContainer == null ? void 0 : scrollContainer.scrollTop) ?? 0;
    const scrollBottom = scrollTop + containerHeight;
    let t = tbodyRef.current;
    let firstElementTop = (t == null ? void 0 : t.offsetTop) ?? 0;
    while ((t == null ? void 0 : t.offsetParent) && (t == null ? void 0 : t.offsetParent) !== scrollContainer) {
      t = t.offsetParent;
      firstElementTop += t.offsetTop;
    }
    if (firstElementTop > scrollBottom || firstElementTop + totalHeightRef.current < scrollTop) {
      return React.createElement("tr", null, React.createElement("td", {
        colSpan: 4,
        style: {
          height: `${totalHeightRef.current}px`
        }
      }));
    }
    const viewportTop = scrollTop - firstElementTop;
    const viewportBottom = scrollBottom - firstElementTop;
    const [startSegment, startLine, endSegment, endLine] = findVisibleLines$1(segmentsRef.current, accTopRef.current, viewportTop, viewportBottom, itemHeight, expandLineHeight);
    const [topHeight, bottomHeight] = calculatePlaceholderHeight$1(segmentsRef.current, accTopRef.current, startSegment, startLine, endSegment, endLine, itemHeight, expandLineHeight, totalHeightRef.current);
    const visibleSegments = segmentsRef.current.slice(startSegment, endSegment + 1);
    return visibleSegments.length ? React.createElement(React.Fragment, null, React.createElement("tr", null, React.createElement("td", {
      colSpan: 4,
      style: {
        height: topHeight,
        padding: 0
      }
    })), visibleSegments.map((segment, index) => renderSegment(segment, index, startLine, endLine, syntaxHighlightEnabled2)), React.createElement("tr", null, React.createElement("td", {
      colSpan: 4,
      style: {
        height: bottomHeight,
        padding: 0
      }
    }))) : React.createElement("tr", null, React.createElement("td", {
      colSpan: 4,
      style: {
        height: `${totalHeightRef.current}px`
      }
    }));
  };
  const renderMeasureLine = () => React.createElement("colgroup", {
    className: "measure-line"
  }, props.lineNumbers && React.createElement("col", {
    style: {
      width: lineNumberWidth
    }
  }), React.createElement("col", null), props.lineNumbers && React.createElement("col", {
    style: {
      width: lineNumberWidth
    }
  }), React.createElement("col", null));
  const classes = [
    "json-diff-viewer",
    props.virtual && "json-diff-viewer-virtual",
    props.syntaxHighlight && `json-diff-viewer-theme-${props.syntaxHighlight.theme || "monokai"}`,
    props.className
  ].filter(Boolean).join(" ");
  const syntaxHighlightEnabled = !!props.syntaxHighlight;
  return React.createElement("table", {
    className: classes,
    style: props.style
  }, renderMeasureLine(), React.createElement("tbody", {
    ref: tbodyRef
  }, renderTbody(syntaxHighlightEnabled)));
};
Viewer.displayName = "Viewer";

// node_modules/json-diff-kit/dist/index.js
var import_react = __toESM(require_react());
export {
  Differ,
  Viewer
};
//# sourceMappingURL=json-diff-kit.js.map
